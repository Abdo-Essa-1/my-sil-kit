VIB Simulation 
================================
.. macros for internal use
.. |ComAdapter| replace:: :doc:`ComAdapter<api/comadapter>`
.. |Middleware| replace:: :doc:`Middleware<configuration/middleware-configuration>`
.. |Participant| replace:: :doc:`Participant<api/participantcontroller>`
.. |System| replace:: :doc:`System<api/synchronisation>`

.. contents::
    :local:
    :depth: 2

This document discusses the distributed algorithm of the integration bus
and the simulation time synchronization.
The state machines which build the foundation for the distributed execution
are shared among all middleware implementations.

However, when the simulation is in a running state, the progress of the 
simulation time is governed by the active middleware, and the selected
time synchronization algorithm and policy.


Distributed State Machine
-------------------------
The Integration Bus simulation relies on a distributed state machine.
The distributed algorithm takes each individual participant's state into 
account and allows for computing a global system state and controlling
the simulation in its entirety.

The underlying |ComAdapter| and |Middleware| implement the low-level 
communication required for the exchange and synchronization of 
state updates.
On top of this, a user accesible API is implemented which allows
introspection of |Participant| states and |System| states, and also
sending commands to transition the system or participants into new states.


The participant lifecycle
~~~~~~~~~~~~~~~~~~~~~~~~~~~
discuss the participants controllers life cycle and how the 
states are transitioned, e.g. by external commands from a system
controller.

.. figure:: _static/ParticipantLifeCycle_1.png
   :alt: The participant controller life cycle
   :align: center
   :width: 80%
   
   The Participant Controller Life Cycle.

The system lifecycle
~~~~~~~~~~~~~~~~~~~~
To understand how each participants state affects the system state
it is helpful to examine the system states

.. figure:: _static/SystemMonitor_1.png
   :alt: The SystemMonitor
   :align: center
   :width: 80%
   
   The SystemMonitor state machine
    

Time Synchronization
--------------------
The Integration Bus supports several different simulation time synchronization
policies and algorithms.
Note that the simulation time only advances when system state is ``running``.

The synchronization policies, listed in the figure below, define the guarantees
about data delivery.

.. list-table:: Synchronization Policies
    :widths: 30 70
    :header-rows: 1

    * - Policy
      - Description
    * - Loose
      - There is no guarantee that data has been received before the next 
        simulation cycle
    * - Strict
      - Enforce that all sent data has been received befor the next
        simulation cycle

Choosing a ``loose`` policy allows running the simulation as fast as possible,
while minimizing the synchronization overhead.
The ``strict`` policy, on the other hand, guarantees that data is received 
orderly before a new simulation cycles starts.


.. list-table:: Synchronization Types
    :widths: 30 70
    :header-rows: 1
    
    * - SyncType
      - Description

    * - DistributedTimeQuantum
      - TimeQuantum synchronization using a distributed algorithm. When using VAsio
        middleware, this SyncType provides inherent strict message delivery.

    * - DiscreteEvent
      - Classic discrete event simulation.

    * - TimeQuantum
      - Dynamic length time quanta requested by the participants.

    * - DiscreteTime
      - Simulation advances according to clock "Ticks" generated by a time master,
        Participant sends a "TickDone" on completion.
            
    * - DiscreteTimePassive
      - Same as DiscreteTime, but the participant only listens to Ticks and does not 
        send a "TickDone".

The :ref:`time synchronization<sec:cfg-time-sync>` and the 
:ref:`synchronization policy<sec:cfg-participant-controller>` can be configured 
using the :doc:`simulation configuration<../configuration/simulation-setup>`.

