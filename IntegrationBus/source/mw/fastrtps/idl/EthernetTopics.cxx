// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file EthernetTopics.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "EthernetTopics.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

ib::sim::eth::idl::EthTagControlInformation::EthTagControlInformation()
{
    m_pcp = 0;
    m_dei = 0;
    m_vid = 0;
}

ib::sim::eth::idl::EthTagControlInformation::~EthTagControlInformation()
{
}

ib::sim::eth::idl::EthTagControlInformation::EthTagControlInformation(const EthTagControlInformation &x)
{
    m_pcp = x.m_pcp;
    m_dei = x.m_dei;
    m_vid = x.m_vid;
}

ib::sim::eth::idl::EthTagControlInformation::EthTagControlInformation(EthTagControlInformation &&x)
{
    m_pcp = x.m_pcp;
    m_dei = x.m_dei;
    m_vid = x.m_vid;
}

ib::sim::eth::idl::EthTagControlInformation& ib::sim::eth::idl::EthTagControlInformation::operator=(const EthTagControlInformation &x)
{
    m_pcp = x.m_pcp;
    m_dei = x.m_dei;
    m_vid = x.m_vid;
    
    return *this;
}

ib::sim::eth::idl::EthTagControlInformation& ib::sim::eth::idl::EthTagControlInformation::operator=(EthTagControlInformation &&x)
{
    m_pcp = x.m_pcp;
    m_dei = x.m_dei;
    m_vid = x.m_vid;
    
    return *this;
}

size_t ib::sim::eth::idl::EthTagControlInformation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

size_t ib::sim::eth::idl::EthTagControlInformation::getCdrSerializedSize(const ib::sim::eth::idl::EthTagControlInformation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void ib::sim::eth::idl::EthTagControlInformation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_pcp;
    scdr << m_dei;
    scdr << m_vid;
}

void ib::sim::eth::idl::EthTagControlInformation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_pcp;
    dcdr >> m_dei;
    dcdr >> m_vid;
}

size_t ib::sim::eth::idl::EthTagControlInformation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool ib::sim::eth::idl::EthTagControlInformation::isKeyDefined()
{
    return false;
}

void ib::sim::eth::idl::EthTagControlInformation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
}

ib::sim::eth::idl::EthMessage::EthMessage()
{

    m_transmitId = 0;
    m_timestampNs = 0;

}

ib::sim::eth::idl::EthMessage::~EthMessage()
{
}

ib::sim::eth::idl::EthMessage::EthMessage(const EthMessage &x)
{
    m_senderAddr = x.m_senderAddr;
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_rawFrame = x.m_rawFrame;
}

ib::sim::eth::idl::EthMessage::EthMessage(EthMessage &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_rawFrame = std::move(x.m_rawFrame);
}

ib::sim::eth::idl::EthMessage& ib::sim::eth::idl::EthMessage::operator=(const EthMessage &x)
{
    m_senderAddr = x.m_senderAddr;
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_rawFrame = x.m_rawFrame;
    
    return *this;
}

ib::sim::eth::idl::EthMessage& ib::sim::eth::idl::EthMessage::operator=(EthMessage &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_rawFrame = std::move(x.m_rawFrame);
    
    return *this;
}

size_t ib::sim::eth::idl::EthMessage::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t ib::sim::eth::idl::EthMessage::getCdrSerializedSize(const ib::sim::eth::idl::EthMessage& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.rawFrame().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void ib::sim::eth::idl::EthMessage::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_transmitId;
    scdr << m_timestampNs;
    scdr << m_rawFrame;
}

void ib::sim::eth::idl::EthMessage::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_transmitId;
    dcdr >> m_timestampNs;
    dcdr >> m_rawFrame;
}

size_t ib::sim::eth::idl::EthMessage::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 




    return current_align;
}

bool ib::sim::eth::idl::EthMessage::isKeyDefined()
{
    return true;
}

void ib::sim::eth::idl::EthMessage::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
}

ib::sim::eth::idl::EthTransmitAcknowledge::EthTransmitAcknowledge()
{

    m_transmitId = 0;
    m_timestampNs = 0;
    m_status = ib::sim::eth::idl::Transmitted;
}

ib::sim::eth::idl::EthTransmitAcknowledge::~EthTransmitAcknowledge()
{
}

ib::sim::eth::idl::EthTransmitAcknowledge::EthTransmitAcknowledge(const EthTransmitAcknowledge &x)
{
    m_senderAddr = x.m_senderAddr;
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_status = x.m_status;
}

ib::sim::eth::idl::EthTransmitAcknowledge::EthTransmitAcknowledge(EthTransmitAcknowledge &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_status = x.m_status;
}

ib::sim::eth::idl::EthTransmitAcknowledge& ib::sim::eth::idl::EthTransmitAcknowledge::operator=(const EthTransmitAcknowledge &x)
{
    m_senderAddr = x.m_senderAddr;
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_status = x.m_status;
    
    return *this;
}

ib::sim::eth::idl::EthTransmitAcknowledge& ib::sim::eth::idl::EthTransmitAcknowledge::operator=(EthTransmitAcknowledge &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_status = x.m_status;
    
    return *this;
}

size_t ib::sim::eth::idl::EthTransmitAcknowledge::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t ib::sim::eth::idl::EthTransmitAcknowledge::getCdrSerializedSize(const ib::sim::eth::idl::EthTransmitAcknowledge& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void ib::sim::eth::idl::EthTransmitAcknowledge::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_transmitId;
    scdr << m_timestampNs;
    scdr << (const uint32_t)m_status;
}

void ib::sim::eth::idl::EthTransmitAcknowledge::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_transmitId;
    dcdr >> m_timestampNs;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_status = (ib::sim::eth::idl::EthTransmitStatus)enum_value;
    }
}

size_t ib::sim::eth::idl::EthTransmitAcknowledge::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 




    return current_align;
}

bool ib::sim::eth::idl::EthTransmitAcknowledge::isKeyDefined()
{
    return true;
}

void ib::sim::eth::idl::EthTransmitAcknowledge::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
}

ib::sim::eth::idl::EthStatus::EthStatus()
{

    m_timestampNs = 0;
    m_state = ib::sim::eth::idl::Inactive;
    m_bitRate = 0;
}

ib::sim::eth::idl::EthStatus::~EthStatus()
{
}

ib::sim::eth::idl::EthStatus::EthStatus(const EthStatus &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timestampNs = x.m_timestampNs;
    m_state = x.m_state;
    m_bitRate = x.m_bitRate;
}

ib::sim::eth::idl::EthStatus::EthStatus(EthStatus &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timestampNs = x.m_timestampNs;
    m_state = x.m_state;
    m_bitRate = x.m_bitRate;
}

ib::sim::eth::idl::EthStatus& ib::sim::eth::idl::EthStatus::operator=(const EthStatus &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timestampNs = x.m_timestampNs;
    m_state = x.m_state;
    m_bitRate = x.m_bitRate;
    
    return *this;
}

ib::sim::eth::idl::EthStatus& ib::sim::eth::idl::EthStatus::operator=(EthStatus &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timestampNs = x.m_timestampNs;
    m_state = x.m_state;
    m_bitRate = x.m_bitRate;
    
    return *this;
}

size_t ib::sim::eth::idl::EthStatus::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t ib::sim::eth::idl::EthStatus::getCdrSerializedSize(const ib::sim::eth::idl::EthStatus& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void ib::sim::eth::idl::EthStatus::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_timestampNs;
    scdr << (const uint32_t)m_state;
    scdr << m_bitRate;
}

void ib::sim::eth::idl::EthStatus::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_timestampNs;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_state = (ib::sim::eth::idl::EthState)enum_value;
    }
    dcdr >> m_bitRate;
}

size_t ib::sim::eth::idl::EthStatus::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 




    return current_align;
}

bool ib::sim::eth::idl::EthStatus::isKeyDefined()
{
    return true;
}

void ib::sim::eth::idl::EthStatus::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
}

ib::sim::eth::idl::EthSetMode::EthSetMode()
{

    m_mode = ib::sim::eth::idl::ModeInactive;
}

ib::sim::eth::idl::EthSetMode::~EthSetMode()
{
}

ib::sim::eth::idl::EthSetMode::EthSetMode(const EthSetMode &x)
{
    m_senderAddr = x.m_senderAddr;
    m_mode = x.m_mode;
}

ib::sim::eth::idl::EthSetMode::EthSetMode(EthSetMode &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_mode = x.m_mode;
}

ib::sim::eth::idl::EthSetMode& ib::sim::eth::idl::EthSetMode::operator=(const EthSetMode &x)
{
    m_senderAddr = x.m_senderAddr;
    m_mode = x.m_mode;
    
    return *this;
}

ib::sim::eth::idl::EthSetMode& ib::sim::eth::idl::EthSetMode::operator=(EthSetMode &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_mode = x.m_mode;
    
    return *this;
}

size_t ib::sim::eth::idl::EthSetMode::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t ib::sim::eth::idl::EthSetMode::getCdrSerializedSize(const ib::sim::eth::idl::EthSetMode& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void ib::sim::eth::idl::EthSetMode::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << (const uint32_t)m_mode;
}

void ib::sim::eth::idl::EthSetMode::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_mode = (ib::sim::eth::idl::EthMode)enum_value;
    }
}

size_t ib::sim::eth::idl::EthSetMode::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 


    return current_align;
}

bool ib::sim::eth::idl::EthSetMode::isKeyDefined()
{
    return true;
}

void ib::sim::eth::idl::EthSetMode::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
}



