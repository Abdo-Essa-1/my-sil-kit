#include "Common.idl"

module ib {
module sim {
module fr {
module idl {

// Type and constants for the FlexRay channel parameter A, B, or AB
enum Channel
{
    None,
    A,
    B,
    AB
};

// Period of the clock (used for micro tick period and sample clock period)
enum ClockPeriod
{
    T12_5NS, // 12.5ns / 80MHz
    T25NS, // 25ns   / 40MHz
    T50NS // 50ns   / 20MHz
};
    
struct ClusterParameters
{
    // Number of attempts for a cold start before giving up (range 2 -31)
    octet gColdstartAttempts;

    // Max number for cycle count (number of cycles - 1)
    octet gCycleCountMax;

    // time offset for a static slot in MacroTicks (MT) (range 1-63)
    unsigned short gdActionPointOffset;

    //// Not used by Network Simulator
    //gdCASRxLowMax   

    // Duration of the idle phase within a dynamic slot in gdMiniSlots (range 0 - 2)
    unsigned short gdDynamicSlotIdlePhase;

    //// Not used by Network Simulator
    //gdIgnoreAfterTx

    // Duration of a mini slot in MacroTicks (MT) (2-63)
    unsigned short gdMiniSlot;

    // Time offset for a mini slot in MacroTicks (MT) (range 1- 31)
    unsigned short gdMiniSlotActionPointOffset;

    // Duration of a static slot in MacroTicks (MT) (3-664)
    unsigned short gdStaticSlot;

    // Duration of the symbol window in MacroTicks (MT) (range1 - 139)
    unsigned short gdSymbolWindow;

    // Time offset for a static symbol windows in MacroTicks (MT) (range 1-63)
    unsigned short gdSymbolWindowActionPointOffset;

    // Duration of TSS (Transmission Start Sequence) in gdBits (range 1-15)
    unsigned short gdTSSTransmitter;

    //// Not used by Network Simulator
    //gdWakeupRxIdle

    //// Not used by Network Simulator
    //gdWakeupRxLow

    //// Not used by Network Simulator
    //gdWakeupRxWindow

    // Duration of LOW Phase of a wakeup symbol in gdBit (range 15 - 60)
    unsigned short gdWakeupTxActive;

    // Duration of the idle of a wakeup symbol in gdBit (45 - 180)
    unsigned short gdWakeupTxIdle;

    // Upper limit for the startup listen timeout and wakeup listen timeout in the
    // presence of noise. Used as a multiplier of pdListenTimeout. (range 2 - 16)
    octet gListenNoise;

    // Number of MacroTicks (MT) per cycle, (range 8 - 16000)
    unsigned short gMacroPerCycle;

    // Threshold used for testing the vClockCorrectionFailed counter (range 1-15)
    octet gMaxWithoutClockCorrectionFatal;

    // Threshold used for testing the vClockCorrectionFailed counter (range 1-15)
    octet gMaxWithoutClockCorrectionPassive;

    // Number of mini slots (range 0-7988)
    unsigned short gNumberOfMiniSlots;

    // Number of static slots in a cycle (range 2-1023)
    unsigned short gNumberOfStaticSlots;

    // Length of the payload of a static frame in 16-Bits words (range 0 - 127)
    unsigned short gPayloadLengthStatic;

    // Max number of distinct sync frame identifiers present in a given cluster. (range 2 - 15)
    octet gSyncFrameIDCountMax;
};

/*! \brief Protocol relevant global node parameters
*
*  Cf. 'FlexRay Protocol Specification Version 3.0.1' Appendix B.3.2 Parameters
*/
struct NodeParameters
{
    // ----------------------------------------------------------------------
    // Parameters according to B.3.2.1

    // Controls the transition to halt state due to clock synchronization errors. (0,1)
    octet pAllowHaltDueToClock;

    // Required number of consecutive even / odd cycle pairs for normal passive to normal active (range 0-31)
    octet pAllowPassiveToActive;

    // Channel(s) to which the controller is connected (values Channel::A, Channel::B, Channel::AB)
    Channel pChannels;

    // Cluster drift damping factor for rate correction in Microticks (range 0 - 10)
    octet pClusterDriftDamping;

    // Allowed deviation for startup frames during integration in MicroTicks (range 29 - 2743 ï¿½T)
    long pdAcceptedStartupRange;

    //// Not used by Network Simulator
    //pDecodingCorrection

    //// Not used by Network Simulator
    //pDelayCompensationA

    //// Not used by Network Simulator
    //pDelayCompensationB

    // Duration of listen phase in MicroTicks (range 1926 - 2567692)
    long pdListenTimeout;

    //// Not used by Network Simulator
    //pExternalSync

    //// Not used by Network Simulator
    //pExternOffsetCorrection

    //// Not used by Network Simulator
    //pExternRateCorrection

    //// Not used by Network Simulator
    //pFallBackInternal

    // Slot ID of the key slot (range 0-1023, value 0 means that there is no key slot)
    unsigned short pKeySlotId;

    // Shall the node enter key slot only mode after startup. (values 0, 1) (AUTOSAR pSingleSlotEnabled)
    octet pKeySlotOnlyEnabled;

    // Key slot is used for startup (range 0, 1)
    octet pKeySlotUsedForStartup;

    // Key slot is used for sync (range 0, 1)
    octet pKeySlotUsedForSync;

    // Last mini slot which can be transmitted (range 0 -7981)
    unsigned short pLatestTx;

    // Initial startup offset for frame reference point on channel A (rang 2-68 MacroTicks (MT))
    octet pMacroInitialOffsetA;

    // Initial startup offset for frame reference point on channel B (rang 2-68 MacroTicks (MT))
    octet pMacroInitialOffsetB;

    // Offset between secondary time reference and MT boundary (range 0 - 239 Microticks)
    long pMicroInitialOffsetA;

    // Offset between secondary time reference and MT boundary (range 0 - 239 Microticks)
    long pMicroInitialOffsetB;

    // Nominal number of microticks in the communication cycle (range 960 - 1280000)
    long pMicroPerCycle;

    // Maximum permissible offset correction value (range 15 - 16082 Microticks)
    long pOffsetCorrectionOut;

    // Start of the offset correction phase within the NIT, (7 - 15999 MT)
    unsigned short pOffsetCorrectionStart;

    // Maximum permissible rate correction value (range 3 - 3846 Microticks)
    long pRateCorrectionOut;

    //// Not used by Network Simulator
    //pSecondKeySlotID

    //// Not used by Network Simulator
    //pTwoKeySlotMode

    // Channel used by the node to send a wakeup pattern (values Channel::A, Channel::B)
    Channel pWakeupChannel;

    // Number of repetitions of the wakeup symbol (range 0-63, value 0 prevents sending of WUP)
    octet pWakeupPattern; 

    // ----------------------------------------------------------------------
    // Parameters according to B.3.2.2

    // Duration of a FlexRay microtick (12.5ns, 25ns or 50ns)
    ClockPeriod pdMicrotick;

    //// Not used by Network Simulator
    //pNMVectorEarlyUpdate

    //// Not used by Network Simulator
    //pPayloadLengthDynMax

    // Number of samples per microtick (values 1 or 2)
    octet pSamplesPerMicrotick;
};

// Transmission mode for FlexRay Tx-Buffer
enum TransmissionMode
{
    SingleShot,
    Continuous
};

//! Configuration of Tx-Buffer, used in struct ControllerConfig
struct TxBufferConfig
{
    // (values Channel::A, Channel::B, Channel::AB)
    Channel channels;

    // The slot Id of frame
    unsigned short slotId;

    // Base offset for cycle multiplexing (values 0-63)
    octet offset;

    // Repetition for cycle multiplexing (values 1,2,4,8,16,32,64)
    octet repetition;

    // Set the PPindicator
    boolean hasPayloadPreambleIndicator;

    // Header CRC, 11 bits
    unsigned short headerCrc;

    // TransmissionMode::SingleShot or TransmissionMode::Continuous
    TransmissionMode transmissionMode;
};
    
//! Configure the communication parameters of the FlexRay controller.
struct ControllerConfig
{
    @Key ib::mw::idl::EndpointAddress senderAddr;
    
    ClusterParameters clusterParams;
    NodeParameters nodeParams;

    sequence<TxBufferConfig> bufferConfigs;
};


//! Update the configuration of a particular FlexRay TX-Buffer
struct TxBufferConfigUpdate
{
    @Key ib::mw::idl::EndpointAddress senderAddr;
    
    // Index of the TX Buffers according to the configured buffers (cf. ControllerConfig)
    unsigned short txBufferIndex;
    // The new configuration of the Tx-Buffer
    TxBufferConfig txBufferConfig;
};

// Update the content of a FlexRay TX-Buffer
struct TxBufferUpdate
{
    @Key ib::mw::idl::EndpointAddress senderAddr;
    
    // Index of the TX Buffers according to the configured buffers (cf. ControllerConfig)
    unsigned short txBufferIndex;

    // Payload data valid flag
    boolean payloadDataValid;

    // Raw payload containing 0 to 254 bytes.
    sequence<octet> payload;
};


enum ChiCommand
{
    RUN,
    DEFERRED_HALT,
    FREEZE,
    ALLOW_COLDSTART,
    ALL_SLOTS,
    WAKEUP
};

struct HostCommand
{
    @Key ib::mw::idl::EndpointAddress senderAddr;
    
    ChiCommand command;
};

struct Header
{
    // Flags bit map according to FlagMask
    // [7-5]: unused
    // [4]: SuFIndicator: 0, not a startup frame; 1, a startup frame
    // [3]: SyFIndicator: 0, frame not used for synchronization; 1, frame shall be used for sync
    // [2]: NFIndicator: 0, no valid payload data and PPIndicator = 0; 1, valid payload data
    // [1]: PPIndicator: 0, regular payload; 1, NM vector or message ID
    // [0]: Reserved bit
    octet flags;

    // Slot ID in which the frame was sent: 1 - 2047
    unsigned short frameId;

    // Payload length, 7 bits
    octet payloadLength;

    // Header CRC, 11 bits
    unsigned short headerCrc;

    // Cycle in which the frame was sent: 0 - 63
    octet cycleCount;
};

struct Frame
{
    // Header flags, slot, crc, and cycle indidcators
    Header header;

    // Raw payload containing 0 to 254 bytes.
    sequence<octet, 254> payload;
};

struct FrMessage
{
    @Key ib::mw::idl::EndpointAddress senderAddr;

    // Time at end of frame transmission
    long long timeNs;

    // FlexRay channel A or B. (Valid values: Channel::A, Channel::B)
    Channel channel;

    Frame frame;
};

// Acknowledge for the transmit on the FlexRay bus
struct FrMessageAck
{
    @Key ib::mw::idl::EndpointAddress senderAddr;

    // Time at end of frame transmission
    long long timeNs;

    // tx buffer, that was used for the transmission
    unsigned short txBufferIndex;

    // FlexRay channel A or B. (Valid values: Channel::A, Channel::B)
    Channel channel;

    // Copy of the FlexRay frame that was successfully transmitted
    Frame frame;
};

// FlexRay symbols patterns.
enum SymbolPattern
{
    CasMts, // Collision avoidance symbol (CAS) OR media access test symbol (MTS)
    Wus,    // Wakeup symbol (WUS)
    Wudop   // Wakeup During Operation Pattern (WUDOP)
};

// A FlexRay Symbol as received on the FlexRay bus.
struct FrSymbol
{
    @Key ib::mw::idl::EndpointAddress senderAddr;

    // End time of symbol reception.
    long long timeNs;

    // namespace fr channel A or B (values: Channel::A, Channel::B)
    Channel channel;

    // The received symbol, e.g. wakeup pattern
    SymbolPattern pattern; 
};

struct FrSymbolAck
{
    @Key ib::mw::idl::EndpointAddress senderAddr;

    FrSymbol symbol;
};

// Indicate the start of a FlexRay cycle
struct CycleStart
{
    @Key ib::mw::idl::EndpointAddress senderAddr;

    // Time of the FlexRay Cycle Start
    long long timeNs;

    // The number of the current cycle
    octet cycleCounter;
};


// Protocol Operation Control (POC) state of the FlexRay communication controller
enum PocState
{
    DefaultConfig, // CC expects configuration. Initial state after reset. 
    Config,        // CC is in configuration Mode for setting communication parameters
    Ready,         // intermediate state for initialization process (after Config)
    Startup,       // namespace fr startup phase
    Wakeup,        // namespace fr wakeup phase
    NormalActive,  // Normal operating mode
    NormalPassive, // Operating mode with transient or tolerable errors
    Halt           // CC is halted, (caused by the application (DeferredHalt) or by a fatal error)
};

// Status of the simulated FlexRay controller
struct ControllerStatus
{
    @Key ib::mw::idl::EndpointAddress senderAddr;

    long long timeNs;

    // Status of the Protocol Operation Control (POC)
    PocState pocState;
};


};
};
};
};
