// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file CanTopics.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "CanTopics.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

ib::sim::can::idl::CanMessageFlags::CanMessageFlags()
{
    m_ide = false;
    m_rtr = false;
    m_fdf = false;
    m_brs = false;
    m_esi = false;
}

ib::sim::can::idl::CanMessageFlags::~CanMessageFlags()
{
}

ib::sim::can::idl::CanMessageFlags::CanMessageFlags(const CanMessageFlags &x)
{
    m_ide = x.m_ide;
    m_rtr = x.m_rtr;
    m_fdf = x.m_fdf;
    m_brs = x.m_brs;
    m_esi = x.m_esi;
}

ib::sim::can::idl::CanMessageFlags::CanMessageFlags(CanMessageFlags &&x)
{
    m_ide = x.m_ide;
    m_rtr = x.m_rtr;
    m_fdf = x.m_fdf;
    m_brs = x.m_brs;
    m_esi = x.m_esi;
}

ib::sim::can::idl::CanMessageFlags& ib::sim::can::idl::CanMessageFlags::operator=(const CanMessageFlags &x)
{
    m_ide = x.m_ide;
    m_rtr = x.m_rtr;
    m_fdf = x.m_fdf;
    m_brs = x.m_brs;
    m_esi = x.m_esi;
    
    return *this;
}

ib::sim::can::idl::CanMessageFlags& ib::sim::can::idl::CanMessageFlags::operator=(CanMessageFlags &&x)
{
    m_ide = x.m_ide;
    m_rtr = x.m_rtr;
    m_fdf = x.m_fdf;
    m_brs = x.m_brs;
    m_esi = x.m_esi;
    
    return *this;
}

size_t ib::sim::can::idl::CanMessageFlags::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t ib::sim::can::idl::CanMessageFlags::getCdrSerializedSize(const ib::sim::can::idl::CanMessageFlags& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void ib::sim::can::idl::CanMessageFlags::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_ide;
    scdr << m_rtr;
    scdr << m_fdf;
    scdr << m_brs;
    scdr << m_esi;
}

void ib::sim::can::idl::CanMessageFlags::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_ide;
    dcdr >> m_rtr;
    dcdr >> m_fdf;
    dcdr >> m_brs;
    dcdr >> m_esi;
}

size_t ib::sim::can::idl::CanMessageFlags::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool ib::sim::can::idl::CanMessageFlags::isKeyDefined()
{
    return false;
}

void ib::sim::can::idl::CanMessageFlags::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}

ib::sim::can::idl::CanMessage::CanMessage()
{

    m_transmitId = 0;
    m_timestampNs = 0;
    m_canId = 0;

    m_dlc = 0;

}

ib::sim::can::idl::CanMessage::~CanMessage()
{
}

ib::sim::can::idl::CanMessage::CanMessage(const CanMessage &x)
{
    m_senderAddr = x.m_senderAddr;
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_canId = x.m_canId;
    m_flags = x.m_flags;
    m_dlc = x.m_dlc;
    m_dataField = x.m_dataField;
}

ib::sim::can::idl::CanMessage::CanMessage(CanMessage &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_canId = x.m_canId;
    m_flags = std::move(x.m_flags);
    m_dlc = x.m_dlc;
    m_dataField = std::move(x.m_dataField);
}

ib::sim::can::idl::CanMessage& ib::sim::can::idl::CanMessage::operator=(const CanMessage &x)
{
    m_senderAddr = x.m_senderAddr;
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_canId = x.m_canId;
    m_flags = x.m_flags;
    m_dlc = x.m_dlc;
    m_dataField = x.m_dataField;
    
    return *this;
}

ib::sim::can::idl::CanMessage& ib::sim::can::idl::CanMessage::operator=(CanMessage &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_transmitId = x.m_transmitId;
    m_timestampNs = x.m_timestampNs;
    m_canId = x.m_canId;
    m_flags = std::move(x.m_flags);
    m_dlc = x.m_dlc;
    m_dataField = std::move(x.m_dataField);
    
    return *this;
}

size_t ib::sim::can::idl::CanMessage::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += ib::sim::can::idl::CanMessageFlags::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t ib::sim::can::idl::CanMessage::getCdrSerializedSize(const ib::sim::can::idl::CanMessage& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += ib::sim::can::idl::CanMessageFlags::getCdrSerializedSize(data.flags(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.dataField().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void ib::sim::can::idl::CanMessage::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_transmitId;
    scdr << m_timestampNs;
    scdr << m_canId;
    scdr << m_flags;
    scdr << m_dlc;
    scdr << m_dataField;
}

void ib::sim::can::idl::CanMessage::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_transmitId;
    dcdr >> m_timestampNs;
    dcdr >> m_canId;
    dcdr >> m_flags;
    dcdr >> m_dlc;
    dcdr >> m_dataField;
}

size_t ib::sim::can::idl::CanMessage::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 







    return current_align;
}

bool ib::sim::can::idl::CanMessage::isKeyDefined()
{
    return true;
}

void ib::sim::can::idl::CanMessage::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
	 
	 
	 
}
ib::sim::can::idl::CanControllerStatus::CanControllerStatus()
{

    m_timestampNs = 0;
    m_controllerState = 0;
    m_errorState = 0;
}

ib::sim::can::idl::CanControllerStatus::~CanControllerStatus()
{
}

ib::sim::can::idl::CanControllerStatus::CanControllerStatus(const CanControllerStatus &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timestampNs = x.m_timestampNs;
    m_controllerState = x.m_controllerState;
    m_errorState = x.m_errorState;
}

ib::sim::can::idl::CanControllerStatus::CanControllerStatus(CanControllerStatus &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timestampNs = x.m_timestampNs;
    m_controllerState = x.m_controllerState;
    m_errorState = x.m_errorState;
}

ib::sim::can::idl::CanControllerStatus& ib::sim::can::idl::CanControllerStatus::operator=(const CanControllerStatus &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timestampNs = x.m_timestampNs;
    m_controllerState = x.m_controllerState;
    m_errorState = x.m_errorState;
    
    return *this;
}

ib::sim::can::idl::CanControllerStatus& ib::sim::can::idl::CanControllerStatus::operator=(CanControllerStatus &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timestampNs = x.m_timestampNs;
    m_controllerState = x.m_controllerState;
    m_errorState = x.m_errorState;
    
    return *this;
}

size_t ib::sim::can::idl::CanControllerStatus::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t ib::sim::can::idl::CanControllerStatus::getCdrSerializedSize(const ib::sim::can::idl::CanControllerStatus& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void ib::sim::can::idl::CanControllerStatus::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_timestampNs;
    scdr << m_controllerState;
    scdr << m_errorState;
}

void ib::sim::can::idl::CanControllerStatus::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_timestampNs;
    dcdr >> m_controllerState;
    dcdr >> m_errorState;
}

size_t ib::sim::can::idl::CanControllerStatus::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 




    return current_align;
}

bool ib::sim::can::idl::CanControllerStatus::isKeyDefined()
{
    return true;
}

void ib::sim::can::idl::CanControllerStatus::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
}
ib::sim::can::idl::CanTransmitAcknowledge::CanTransmitAcknowledge()
{

    m_transmitId = 0;
    m_timestampNS = 0;
    m_txStatus = 0;
}

ib::sim::can::idl::CanTransmitAcknowledge::~CanTransmitAcknowledge()
{
}

ib::sim::can::idl::CanTransmitAcknowledge::CanTransmitAcknowledge(const CanTransmitAcknowledge &x)
{
    m_senderAddr = x.m_senderAddr;
    m_transmitId = x.m_transmitId;
    m_timestampNS = x.m_timestampNS;
    m_txStatus = x.m_txStatus;
}

ib::sim::can::idl::CanTransmitAcknowledge::CanTransmitAcknowledge(CanTransmitAcknowledge &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_transmitId = x.m_transmitId;
    m_timestampNS = x.m_timestampNS;
    m_txStatus = x.m_txStatus;
}

ib::sim::can::idl::CanTransmitAcknowledge& ib::sim::can::idl::CanTransmitAcknowledge::operator=(const CanTransmitAcknowledge &x)
{
    m_senderAddr = x.m_senderAddr;
    m_transmitId = x.m_transmitId;
    m_timestampNS = x.m_timestampNS;
    m_txStatus = x.m_txStatus;
    
    return *this;
}

ib::sim::can::idl::CanTransmitAcknowledge& ib::sim::can::idl::CanTransmitAcknowledge::operator=(CanTransmitAcknowledge &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_transmitId = x.m_transmitId;
    m_timestampNS = x.m_timestampNS;
    m_txStatus = x.m_txStatus;
    
    return *this;
}

size_t ib::sim::can::idl::CanTransmitAcknowledge::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t ib::sim::can::idl::CanTransmitAcknowledge::getCdrSerializedSize(const ib::sim::can::idl::CanTransmitAcknowledge& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void ib::sim::can::idl::CanTransmitAcknowledge::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_transmitId;
    scdr << m_timestampNS;
    scdr << m_txStatus;
}

void ib::sim::can::idl::CanTransmitAcknowledge::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_transmitId;
    dcdr >> m_timestampNS;
    dcdr >> m_txStatus;
}

size_t ib::sim::can::idl::CanTransmitAcknowledge::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 




    return current_align;
}

bool ib::sim::can::idl::CanTransmitAcknowledge::isKeyDefined()
{
    return true;
}

void ib::sim::can::idl::CanTransmitAcknowledge::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
}
ib::sim::can::idl::CanConfigureBaudrate::CanConfigureBaudrate()
{

    m_baudRate = 0;
    m_fdBaudRate = 0;
}

ib::sim::can::idl::CanConfigureBaudrate::~CanConfigureBaudrate()
{
}

ib::sim::can::idl::CanConfigureBaudrate::CanConfigureBaudrate(const CanConfigureBaudrate &x)
{
    m_senderAddr = x.m_senderAddr;
    m_baudRate = x.m_baudRate;
    m_fdBaudRate = x.m_fdBaudRate;
}

ib::sim::can::idl::CanConfigureBaudrate::CanConfigureBaudrate(CanConfigureBaudrate &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_baudRate = x.m_baudRate;
    m_fdBaudRate = x.m_fdBaudRate;
}

ib::sim::can::idl::CanConfigureBaudrate& ib::sim::can::idl::CanConfigureBaudrate::operator=(const CanConfigureBaudrate &x)
{
    m_senderAddr = x.m_senderAddr;
    m_baudRate = x.m_baudRate;
    m_fdBaudRate = x.m_fdBaudRate;
    
    return *this;
}

ib::sim::can::idl::CanConfigureBaudrate& ib::sim::can::idl::CanConfigureBaudrate::operator=(CanConfigureBaudrate &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_baudRate = x.m_baudRate;
    m_fdBaudRate = x.m_fdBaudRate;
    
    return *this;
}

size_t ib::sim::can::idl::CanConfigureBaudrate::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t ib::sim::can::idl::CanConfigureBaudrate::getCdrSerializedSize(const ib::sim::can::idl::CanConfigureBaudrate& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void ib::sim::can::idl::CanConfigureBaudrate::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_baudRate;
    scdr << m_fdBaudRate;
}

void ib::sim::can::idl::CanConfigureBaudrate::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_baudRate;
    dcdr >> m_fdBaudRate;
}

size_t ib::sim::can::idl::CanConfigureBaudrate::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 



    return current_align;
}

bool ib::sim::can::idl::CanConfigureBaudrate::isKeyDefined()
{
    return true;
}

void ib::sim::can::idl::CanConfigureBaudrate::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
}
ib::sim::can::idl::CanSetControllerMode::CanSetControllerMode()
{

    m_resetErrorHandling = false;
    m_cancelTransmitRequests = false;
    m_mode = 0;
}

ib::sim::can::idl::CanSetControllerMode::~CanSetControllerMode()
{
}

ib::sim::can::idl::CanSetControllerMode::CanSetControllerMode(const CanSetControllerMode &x)
{
    m_senderAddr = x.m_senderAddr;
    m_resetErrorHandling = x.m_resetErrorHandling;
    m_cancelTransmitRequests = x.m_cancelTransmitRequests;
    m_mode = x.m_mode;
}

ib::sim::can::idl::CanSetControllerMode::CanSetControllerMode(CanSetControllerMode &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_resetErrorHandling = x.m_resetErrorHandling;
    m_cancelTransmitRequests = x.m_cancelTransmitRequests;
    m_mode = x.m_mode;
}

ib::sim::can::idl::CanSetControllerMode& ib::sim::can::idl::CanSetControllerMode::operator=(const CanSetControllerMode &x)
{
    m_senderAddr = x.m_senderAddr;
    m_resetErrorHandling = x.m_resetErrorHandling;
    m_cancelTransmitRequests = x.m_cancelTransmitRequests;
    m_mode = x.m_mode;
    
    return *this;
}

ib::sim::can::idl::CanSetControllerMode& ib::sim::can::idl::CanSetControllerMode::operator=(CanSetControllerMode &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_resetErrorHandling = x.m_resetErrorHandling;
    m_cancelTransmitRequests = x.m_cancelTransmitRequests;
    m_mode = x.m_mode;
    
    return *this;
}

size_t ib::sim::can::idl::CanSetControllerMode::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t ib::sim::can::idl::CanSetControllerMode::getCdrSerializedSize(const ib::sim::can::idl::CanSetControllerMode& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void ib::sim::can::idl::CanSetControllerMode::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_resetErrorHandling;
    scdr << m_cancelTransmitRequests;
    scdr << m_mode;
}

void ib::sim::can::idl::CanSetControllerMode::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_resetErrorHandling;
    dcdr >> m_cancelTransmitRequests;
    dcdr >> m_mode;
}

size_t ib::sim::can::idl::CanSetControllerMode::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 




    return current_align;
}

bool ib::sim::can::idl::CanSetControllerMode::isKeyDefined()
{
    return true;
}

void ib::sim::can::idl::CanSetControllerMode::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
}



