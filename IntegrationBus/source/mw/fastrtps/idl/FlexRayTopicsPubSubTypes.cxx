// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file FlexRayTopicsPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

#include "FlexRayTopicsPubSubTypes.h"

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;

namespace ib
{
    namespace sim
    {
        namespace fr
        {
            namespace idl
            {


                ClusterParametersPubSubType::ClusterParametersPubSubType() {
                    setName("ib::sim::fr::idl::ClusterParameters");
                    m_typeSize = (uint32_t)ClusterParameters::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = ClusterParameters::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(ClusterParameters::getKeyMaxCdrSerializedSize()>16 ? ClusterParameters::getKeyMaxCdrSerializedSize() : 16);
                }

                ClusterParametersPubSubType::~ClusterParametersPubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool ClusterParametersPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    ClusterParameters *p_type = (ClusterParameters*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool ClusterParametersPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    ClusterParameters* p_type = (ClusterParameters*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> ClusterParametersPubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<ClusterParameters*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* ClusterParametersPubSubType::createData() {
                    return (void*)new ClusterParameters();
                }

                void ClusterParametersPubSubType::deleteData(void* data) {
                    delete((ClusterParameters*)data);
                }

                bool ClusterParametersPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    ClusterParameters* p_type = (ClusterParameters*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ClusterParameters::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(ClusterParameters::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                NodeParametersPubSubType::NodeParametersPubSubType() {
                    setName("ib::sim::fr::idl::NodeParameters");
                    m_typeSize = (uint32_t)NodeParameters::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = NodeParameters::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(NodeParameters::getKeyMaxCdrSerializedSize()>16 ? NodeParameters::getKeyMaxCdrSerializedSize() : 16);
                }

                NodeParametersPubSubType::~NodeParametersPubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool NodeParametersPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    NodeParameters *p_type = (NodeParameters*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool NodeParametersPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    NodeParameters* p_type = (NodeParameters*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> NodeParametersPubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<NodeParameters*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* NodeParametersPubSubType::createData() {
                    return (void*)new NodeParameters();
                }

                void NodeParametersPubSubType::deleteData(void* data) {
                    delete((NodeParameters*)data);
                }

                bool NodeParametersPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    NodeParameters* p_type = (NodeParameters*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,NodeParameters::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(NodeParameters::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }


                TxBufferConfigPubSubType::TxBufferConfigPubSubType() {
                    setName("ib::sim::fr::idl::TxBufferConfig");
                    m_typeSize = (uint32_t)TxBufferConfig::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = TxBufferConfig::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(TxBufferConfig::getKeyMaxCdrSerializedSize()>16 ? TxBufferConfig::getKeyMaxCdrSerializedSize() : 16);
                }

                TxBufferConfigPubSubType::~TxBufferConfigPubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool TxBufferConfigPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    TxBufferConfig *p_type = (TxBufferConfig*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool TxBufferConfigPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    TxBufferConfig* p_type = (TxBufferConfig*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> TxBufferConfigPubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<TxBufferConfig*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* TxBufferConfigPubSubType::createData() {
                    return (void*)new TxBufferConfig();
                }

                void TxBufferConfigPubSubType::deleteData(void* data) {
                    delete((TxBufferConfig*)data);
                }

                bool TxBufferConfigPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    TxBufferConfig* p_type = (TxBufferConfig*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TxBufferConfig::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(TxBufferConfig::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                ControllerConfigPubSubType::ControllerConfigPubSubType() {
                    setName("ib::sim::fr::idl::ControllerConfig");
                    m_typeSize = (uint32_t)ControllerConfig::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = ControllerConfig::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(ControllerConfig::getKeyMaxCdrSerializedSize()>16 ? ControllerConfig::getKeyMaxCdrSerializedSize() : 16);
                }

                ControllerConfigPubSubType::~ControllerConfigPubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool ControllerConfigPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    ControllerConfig *p_type = (ControllerConfig*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool ControllerConfigPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    ControllerConfig* p_type = (ControllerConfig*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> ControllerConfigPubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<ControllerConfig*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* ControllerConfigPubSubType::createData() {
                    return (void*)new ControllerConfig();
                }

                void ControllerConfigPubSubType::deleteData(void* data) {
                    delete((ControllerConfig*)data);
                }

                bool ControllerConfigPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    ControllerConfig* p_type = (ControllerConfig*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ControllerConfig::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(ControllerConfig::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                TxBufferUpdatePubSubType::TxBufferUpdatePubSubType() {
                    setName("ib::sim::fr::idl::TxBufferUpdate");
                    m_typeSize = (uint32_t)TxBufferUpdate::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = TxBufferUpdate::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(TxBufferUpdate::getKeyMaxCdrSerializedSize()>16 ? TxBufferUpdate::getKeyMaxCdrSerializedSize() : 16);
                }

                TxBufferUpdatePubSubType::~TxBufferUpdatePubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool TxBufferUpdatePubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    TxBufferUpdate *p_type = (TxBufferUpdate*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool TxBufferUpdatePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    TxBufferUpdate* p_type = (TxBufferUpdate*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> TxBufferUpdatePubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<TxBufferUpdate*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* TxBufferUpdatePubSubType::createData() {
                    return (void*)new TxBufferUpdate();
                }

                void TxBufferUpdatePubSubType::deleteData(void* data) {
                    delete((TxBufferUpdate*)data);
                }

                bool TxBufferUpdatePubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    TxBufferUpdate* p_type = (TxBufferUpdate*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,TxBufferUpdate::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(TxBufferUpdate::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }


                HostCommandPubSubType::HostCommandPubSubType() {
                    setName("ib::sim::fr::idl::HostCommand");
                    m_typeSize = (uint32_t)HostCommand::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = HostCommand::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(HostCommand::getKeyMaxCdrSerializedSize()>16 ? HostCommand::getKeyMaxCdrSerializedSize() : 16);
                }

                HostCommandPubSubType::~HostCommandPubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool HostCommandPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    HostCommand *p_type = (HostCommand*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool HostCommandPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    HostCommand* p_type = (HostCommand*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> HostCommandPubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<HostCommand*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* HostCommandPubSubType::createData() {
                    return (void*)new HostCommand();
                }

                void HostCommandPubSubType::deleteData(void* data) {
                    delete((HostCommand*)data);
                }

                bool HostCommandPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    HostCommand* p_type = (HostCommand*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,HostCommand::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(HostCommand::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                HeaderPubSubType::HeaderPubSubType() {
                    setName("ib::sim::fr::idl::Header");
                    m_typeSize = (uint32_t)Header::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = Header::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(Header::getKeyMaxCdrSerializedSize()>16 ? Header::getKeyMaxCdrSerializedSize() : 16);
                }

                HeaderPubSubType::~HeaderPubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool HeaderPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    Header *p_type = (Header*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool HeaderPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    Header* p_type = (Header*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> HeaderPubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<Header*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* HeaderPubSubType::createData() {
                    return (void*)new Header();
                }

                void HeaderPubSubType::deleteData(void* data) {
                    delete((Header*)data);
                }

                bool HeaderPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    Header* p_type = (Header*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Header::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(Header::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                FramePubSubType::FramePubSubType() {
                    setName("ib::sim::fr::idl::Frame");
                    m_typeSize = (uint32_t)Frame::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = Frame::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(Frame::getKeyMaxCdrSerializedSize()>16 ? Frame::getKeyMaxCdrSerializedSize() : 16);
                }

                FramePubSubType::~FramePubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool FramePubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    Frame *p_type = (Frame*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool FramePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    Frame* p_type = (Frame*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> FramePubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<Frame*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* FramePubSubType::createData() {
                    return (void*)new Frame();
                }

                void FramePubSubType::deleteData(void* data) {
                    delete((Frame*)data);
                }

                bool FramePubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    Frame* p_type = (Frame*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Frame::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(Frame::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                FrMessagePubSubType::FrMessagePubSubType() {
                    setName("ib::sim::fr::idl::FrMessage");
                    m_typeSize = (uint32_t)FrMessage::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = FrMessage::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(FrMessage::getKeyMaxCdrSerializedSize()>16 ? FrMessage::getKeyMaxCdrSerializedSize() : 16);
                }

                FrMessagePubSubType::~FrMessagePubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool FrMessagePubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    FrMessage *p_type = (FrMessage*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool FrMessagePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    FrMessage* p_type = (FrMessage*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> FrMessagePubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<FrMessage*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* FrMessagePubSubType::createData() {
                    return (void*)new FrMessage();
                }

                void FrMessagePubSubType::deleteData(void* data) {
                    delete((FrMessage*)data);
                }

                bool FrMessagePubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    FrMessage* p_type = (FrMessage*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,FrMessage::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(FrMessage::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                FrMessageAckPubSubType::FrMessageAckPubSubType() {
                    setName("ib::sim::fr::idl::FrMessageAck");
                    m_typeSize = (uint32_t)FrMessageAck::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = FrMessageAck::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(FrMessageAck::getKeyMaxCdrSerializedSize()>16 ? FrMessageAck::getKeyMaxCdrSerializedSize() : 16);
                }

                FrMessageAckPubSubType::~FrMessageAckPubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool FrMessageAckPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    FrMessageAck *p_type = (FrMessageAck*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool FrMessageAckPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    FrMessageAck* p_type = (FrMessageAck*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> FrMessageAckPubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<FrMessageAck*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* FrMessageAckPubSubType::createData() {
                    return (void*)new FrMessageAck();
                }

                void FrMessageAckPubSubType::deleteData(void* data) {
                    delete((FrMessageAck*)data);
                }

                bool FrMessageAckPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    FrMessageAck* p_type = (FrMessageAck*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,FrMessageAck::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(FrMessageAck::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }


                FrSymbolPubSubType::FrSymbolPubSubType() {
                    setName("ib::sim::fr::idl::FrSymbol");
                    m_typeSize = (uint32_t)FrSymbol::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = FrSymbol::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(FrSymbol::getKeyMaxCdrSerializedSize()>16 ? FrSymbol::getKeyMaxCdrSerializedSize() : 16);
                }

                FrSymbolPubSubType::~FrSymbolPubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool FrSymbolPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    FrSymbol *p_type = (FrSymbol*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool FrSymbolPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    FrSymbol* p_type = (FrSymbol*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> FrSymbolPubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<FrSymbol*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* FrSymbolPubSubType::createData() {
                    return (void*)new FrSymbol();
                }

                void FrSymbolPubSubType::deleteData(void* data) {
                    delete((FrSymbol*)data);
                }

                bool FrSymbolPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    FrSymbol* p_type = (FrSymbol*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,FrSymbol::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(FrSymbol::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                FrSymbolAckPubSubType::FrSymbolAckPubSubType() {
                    setName("ib::sim::fr::idl::FrSymbolAck");
                    m_typeSize = (uint32_t)FrSymbolAck::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = FrSymbolAck::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(FrSymbolAck::getKeyMaxCdrSerializedSize()>16 ? FrSymbolAck::getKeyMaxCdrSerializedSize() : 16);
                }

                FrSymbolAckPubSubType::~FrSymbolAckPubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool FrSymbolAckPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    FrSymbolAck *p_type = (FrSymbolAck*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool FrSymbolAckPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    FrSymbolAck* p_type = (FrSymbolAck*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> FrSymbolAckPubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<FrSymbolAck*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* FrSymbolAckPubSubType::createData() {
                    return (void*)new FrSymbolAck();
                }

                void FrSymbolAckPubSubType::deleteData(void* data) {
                    delete((FrSymbolAck*)data);
                }

                bool FrSymbolAckPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    FrSymbolAck* p_type = (FrSymbolAck*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,FrSymbolAck::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(FrSymbolAck::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }


                ControllerStatusPubSubType::ControllerStatusPubSubType() {
                    setName("ib::sim::fr::idl::ControllerStatus");
                    m_typeSize = (uint32_t)ControllerStatus::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                    m_isGetKeyDefined = ControllerStatus::isKeyDefined();
                    m_keyBuffer = (unsigned char*)malloc(ControllerStatus::getKeyMaxCdrSerializedSize()>16 ? ControllerStatus::getKeyMaxCdrSerializedSize() : 16);
                }

                ControllerStatusPubSubType::~ControllerStatusPubSubType() {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool ControllerStatusPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                    ControllerStatus *p_type = (ControllerStatus*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                    return true;
                }

                bool ControllerStatusPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                    ControllerStatus* p_type = (ControllerStatus*) data; 	//Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> ControllerStatusPubSubType::getSerializedSizeProvider(void* data) {
                    return [data]() -> uint32_t
                    {
                        return (uint32_t)type::getCdrSerializedSize(*static_cast<ControllerStatus*>(data)) + 4 /*encapsulation*/;
                    };
                }

                void* ControllerStatusPubSubType::createData() {
                    return (void*)new ControllerStatus();
                }

                void ControllerStatusPubSubType::deleteData(void* data) {
                    delete((ControllerStatus*)data);
                }

                bool ControllerStatusPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                    if(!m_isGetKeyDefined)
                        return false;
                    ControllerStatus* p_type = (ControllerStatus*) data;
                    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,ControllerStatus::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(ControllerStatus::getKeyMaxCdrSerializedSize()>16)	{
                        m_md5.init();
                        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)    	{
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }


            } //End of namespace idl

        } //End of namespace fr

    } //End of namespace sim

} //End of namespace ib
