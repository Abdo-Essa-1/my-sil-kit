// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file FlexRayTopicsPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

#include "FlexRayTopicsPubSubTypes.h"

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;

namespace ib
{
    namespace sim
    {
        namespace fr
        {
            namespace idl
            {


                ClusterParametersPubSubType::ClusterParametersPubSubType()
                {
                    setName("ib::sim::fr::idl::ClusterParameters");
                    m_typeSize = static_cast<uint32_t>(ClusterParameters::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = ClusterParameters::isKeyDefined();
                    size_t keyLength = ClusterParameters::getKeyMaxCdrSerializedSize()>16 ? ClusterParameters::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                ClusterParametersPubSubType::~ClusterParametersPubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool ClusterParametersPubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    ClusterParameters *p_type = static_cast<ClusterParameters*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool ClusterParametersPubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    ClusterParameters* p_type = static_cast<ClusterParameters*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> ClusterParametersPubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<ClusterParameters*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* ClusterParametersPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new ClusterParameters());
                }

                void ClusterParametersPubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<ClusterParameters*>(data));
                }

                bool ClusterParametersPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    ClusterParameters* p_type = static_cast<ClusterParameters*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),ClusterParameters::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || ClusterParameters::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                NodeParametersPubSubType::NodeParametersPubSubType()
                {
                    setName("ib::sim::fr::idl::NodeParameters");
                    m_typeSize = static_cast<uint32_t>(NodeParameters::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = NodeParameters::isKeyDefined();
                    size_t keyLength = NodeParameters::getKeyMaxCdrSerializedSize()>16 ? NodeParameters::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                NodeParametersPubSubType::~NodeParametersPubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool NodeParametersPubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    NodeParameters *p_type = static_cast<NodeParameters*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool NodeParametersPubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    NodeParameters* p_type = static_cast<NodeParameters*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> NodeParametersPubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<NodeParameters*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* NodeParametersPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new NodeParameters());
                }

                void NodeParametersPubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<NodeParameters*>(data));
                }

                bool NodeParametersPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    NodeParameters* p_type = static_cast<NodeParameters*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),NodeParameters::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || NodeParameters::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }


                TxBufferConfigPubSubType::TxBufferConfigPubSubType()
                {
                    setName("ib::sim::fr::idl::TxBufferConfig");
                    m_typeSize = static_cast<uint32_t>(TxBufferConfig::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = TxBufferConfig::isKeyDefined();
                    size_t keyLength = TxBufferConfig::getKeyMaxCdrSerializedSize()>16 ? TxBufferConfig::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                TxBufferConfigPubSubType::~TxBufferConfigPubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool TxBufferConfigPubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    TxBufferConfig *p_type = static_cast<TxBufferConfig*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool TxBufferConfigPubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    TxBufferConfig* p_type = static_cast<TxBufferConfig*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> TxBufferConfigPubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<TxBufferConfig*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* TxBufferConfigPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new TxBufferConfig());
                }

                void TxBufferConfigPubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<TxBufferConfig*>(data));
                }

                bool TxBufferConfigPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    TxBufferConfig* p_type = static_cast<TxBufferConfig*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),TxBufferConfig::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || TxBufferConfig::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                ControllerConfigPubSubType::ControllerConfigPubSubType()
                {
                    setName("ib::sim::fr::idl::ControllerConfig");
                    m_typeSize = static_cast<uint32_t>(ControllerConfig::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = ControllerConfig::isKeyDefined();
                    size_t keyLength = ControllerConfig::getKeyMaxCdrSerializedSize()>16 ? ControllerConfig::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                ControllerConfigPubSubType::~ControllerConfigPubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool ControllerConfigPubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    ControllerConfig *p_type = static_cast<ControllerConfig*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool ControllerConfigPubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    ControllerConfig* p_type = static_cast<ControllerConfig*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> ControllerConfigPubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<ControllerConfig*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* ControllerConfigPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new ControllerConfig());
                }

                void ControllerConfigPubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<ControllerConfig*>(data));
                }

                bool ControllerConfigPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    ControllerConfig* p_type = static_cast<ControllerConfig*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),ControllerConfig::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || ControllerConfig::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                TxBufferUpdatePubSubType::TxBufferUpdatePubSubType()
                {
                    setName("ib::sim::fr::idl::TxBufferUpdate");
                    m_typeSize = static_cast<uint32_t>(TxBufferUpdate::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = TxBufferUpdate::isKeyDefined();
                    size_t keyLength = TxBufferUpdate::getKeyMaxCdrSerializedSize()>16 ? TxBufferUpdate::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                TxBufferUpdatePubSubType::~TxBufferUpdatePubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool TxBufferUpdatePubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    TxBufferUpdate *p_type = static_cast<TxBufferUpdate*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool TxBufferUpdatePubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    TxBufferUpdate* p_type = static_cast<TxBufferUpdate*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> TxBufferUpdatePubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<TxBufferUpdate*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* TxBufferUpdatePubSubType::createData()
                {
                    return reinterpret_cast<void*>(new TxBufferUpdate());
                }

                void TxBufferUpdatePubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<TxBufferUpdate*>(data));
                }

                bool TxBufferUpdatePubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    TxBufferUpdate* p_type = static_cast<TxBufferUpdate*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),TxBufferUpdate::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || TxBufferUpdate::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }


                HostCommandPubSubType::HostCommandPubSubType()
                {
                    setName("ib::sim::fr::idl::HostCommand");
                    m_typeSize = static_cast<uint32_t>(HostCommand::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = HostCommand::isKeyDefined();
                    size_t keyLength = HostCommand::getKeyMaxCdrSerializedSize()>16 ? HostCommand::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                HostCommandPubSubType::~HostCommandPubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool HostCommandPubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    HostCommand *p_type = static_cast<HostCommand*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool HostCommandPubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    HostCommand* p_type = static_cast<HostCommand*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> HostCommandPubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<HostCommand*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* HostCommandPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new HostCommand());
                }

                void HostCommandPubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<HostCommand*>(data));
                }

                bool HostCommandPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    HostCommand* p_type = static_cast<HostCommand*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),HostCommand::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || HostCommand::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                HeaderPubSubType::HeaderPubSubType()
                {
                    setName("ib::sim::fr::idl::Header");
                    m_typeSize = static_cast<uint32_t>(Header::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = Header::isKeyDefined();
                    size_t keyLength = Header::getKeyMaxCdrSerializedSize()>16 ? Header::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                HeaderPubSubType::~HeaderPubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool HeaderPubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    Header *p_type = static_cast<Header*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool HeaderPubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    Header* p_type = static_cast<Header*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> HeaderPubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Header*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* HeaderPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new Header());
                }

                void HeaderPubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<Header*>(data));
                }

                bool HeaderPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    Header* p_type = static_cast<Header*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Header::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || Header::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                FramePubSubType::FramePubSubType()
                {
                    setName("ib::sim::fr::idl::Frame");
                    m_typeSize = static_cast<uint32_t>(Frame::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = Frame::isKeyDefined();
                    size_t keyLength = Frame::getKeyMaxCdrSerializedSize()>16 ? Frame::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                FramePubSubType::~FramePubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool FramePubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    Frame *p_type = static_cast<Frame*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool FramePubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    Frame* p_type = static_cast<Frame*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> FramePubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Frame*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* FramePubSubType::createData()
                {
                    return reinterpret_cast<void*>(new Frame());
                }

                void FramePubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<Frame*>(data));
                }

                bool FramePubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    Frame* p_type = static_cast<Frame*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Frame::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || Frame::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                FrMessagePubSubType::FrMessagePubSubType()
                {
                    setName("ib::sim::fr::idl::FrMessage");
                    m_typeSize = static_cast<uint32_t>(FrMessage::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = FrMessage::isKeyDefined();
                    size_t keyLength = FrMessage::getKeyMaxCdrSerializedSize()>16 ? FrMessage::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                FrMessagePubSubType::~FrMessagePubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool FrMessagePubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    FrMessage *p_type = static_cast<FrMessage*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool FrMessagePubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    FrMessage* p_type = static_cast<FrMessage*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> FrMessagePubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<FrMessage*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* FrMessagePubSubType::createData()
                {
                    return reinterpret_cast<void*>(new FrMessage());
                }

                void FrMessagePubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<FrMessage*>(data));
                }

                bool FrMessagePubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    FrMessage* p_type = static_cast<FrMessage*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),FrMessage::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || FrMessage::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                FrMessageAckPubSubType::FrMessageAckPubSubType()
                {
                    setName("ib::sim::fr::idl::FrMessageAck");
                    m_typeSize = static_cast<uint32_t>(FrMessageAck::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = FrMessageAck::isKeyDefined();
                    size_t keyLength = FrMessageAck::getKeyMaxCdrSerializedSize()>16 ? FrMessageAck::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                FrMessageAckPubSubType::~FrMessageAckPubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool FrMessageAckPubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    FrMessageAck *p_type = static_cast<FrMessageAck*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool FrMessageAckPubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    FrMessageAck* p_type = static_cast<FrMessageAck*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> FrMessageAckPubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<FrMessageAck*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* FrMessageAckPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new FrMessageAck());
                }

                void FrMessageAckPubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<FrMessageAck*>(data));
                }

                bool FrMessageAckPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    FrMessageAck* p_type = static_cast<FrMessageAck*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),FrMessageAck::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || FrMessageAck::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }


                FrSymbolPubSubType::FrSymbolPubSubType()
                {
                    setName("ib::sim::fr::idl::FrSymbol");
                    m_typeSize = static_cast<uint32_t>(FrSymbol::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = FrSymbol::isKeyDefined();
                    size_t keyLength = FrSymbol::getKeyMaxCdrSerializedSize()>16 ? FrSymbol::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                FrSymbolPubSubType::~FrSymbolPubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool FrSymbolPubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    FrSymbol *p_type = static_cast<FrSymbol*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool FrSymbolPubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    FrSymbol* p_type = static_cast<FrSymbol*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> FrSymbolPubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<FrSymbol*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* FrSymbolPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new FrSymbol());
                }

                void FrSymbolPubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<FrSymbol*>(data));
                }

                bool FrSymbolPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    FrSymbol* p_type = static_cast<FrSymbol*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),FrSymbol::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || FrSymbol::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }

                FrSymbolAckPubSubType::FrSymbolAckPubSubType()
                {
                    setName("ib::sim::fr::idl::FrSymbolAck");
                    m_typeSize = static_cast<uint32_t>(FrSymbolAck::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = FrSymbolAck::isKeyDefined();
                    size_t keyLength = FrSymbolAck::getKeyMaxCdrSerializedSize()>16 ? FrSymbolAck::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                FrSymbolAckPubSubType::~FrSymbolAckPubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool FrSymbolAckPubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    FrSymbolAck *p_type = static_cast<FrSymbolAck*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool FrSymbolAckPubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    FrSymbolAck* p_type = static_cast<FrSymbolAck*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> FrSymbolAckPubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<FrSymbolAck*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* FrSymbolAckPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new FrSymbolAck());
                }

                void FrSymbolAckPubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<FrSymbolAck*>(data));
                }

                bool FrSymbolAckPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    FrSymbolAck* p_type = static_cast<FrSymbolAck*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),FrSymbolAck::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || FrSymbolAck::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }


                ControllerStatusPubSubType::ControllerStatusPubSubType()
                {
                    setName("ib::sim::fr::idl::ControllerStatus");
                    m_typeSize = static_cast<uint32_t>(ControllerStatus::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                    m_isGetKeyDefined = ControllerStatus::isKeyDefined();
                    size_t keyLength = ControllerStatus::getKeyMaxCdrSerializedSize()>16 ? ControllerStatus::getKeyMaxCdrSerializedSize() : 16;
                    m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                    memset(m_keyBuffer, 0, keyLength);
                }

                ControllerStatusPubSubType::~ControllerStatusPubSubType()
                {
                    if(m_keyBuffer!=nullptr)
                        free(m_keyBuffer);
                }

                bool ControllerStatusPubSubType::serialize(void *data, SerializedPayload_t *payload)
                {
                    ControllerStatus *p_type = static_cast<ControllerStatus*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                    // Serialize encapsulation
                    ser.serialize_encapsulation();

                    try
                    {
                        p_type->serialize(ser); // Serialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                    return true;
                }

                bool ControllerStatusPubSubType::deserialize(SerializedPayload_t* payload, void* data)
                {
                    ControllerStatus* p_type = static_cast<ControllerStatus*>(data); //Convert DATA to pointer of your type
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                    // Deserialize encapsulation.
                    deser.read_encapsulation();
                    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                    try
                    {
                        p_type->deserialize(deser); //Deserialize the object:
                    }
                    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                    {
                        return false;
                    }

                    return true;
                }

                std::function<uint32_t()> ControllerStatusPubSubType::getSerializedSizeProvider(void* data)
                {
                    return [data]() -> uint32_t
                    {
                        return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<ControllerStatus*>(data))) + 4 /*encapsulation*/;
                    };
                }

                void* ControllerStatusPubSubType::createData()
                {
                    return reinterpret_cast<void*>(new ControllerStatus());
                }

                void ControllerStatusPubSubType::deleteData(void* data)
                {
                    delete(reinterpret_cast<ControllerStatus*>(data));
                }

                bool ControllerStatusPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
                {
                    if(!m_isGetKeyDefined)
                        return false;
                    ControllerStatus* p_type = static_cast<ControllerStatus*>(data);
                    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),ControllerStatus::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                    p_type->serializeKey(ser);
                    if(force_md5 || ControllerStatus::getKeyMaxCdrSerializedSize()>16)    {
                        m_md5.init();
                        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                        m_md5.finalize();
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_md5.digest[i];
                        }
                    }
                    else    {
                        for(uint8_t i = 0;i<16;++i)        {
                            handle->value[i] = m_keyBuffer[i];
                        }
                    }
                    return true;
                }


            } //End of namespace idl

        } //End of namespace fr

    } //End of namespace sim

} //End of namespace ib
