// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file FlexRayTopics.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "FlexRayTopics.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>



ib::sim::fr::idl::ClusterParameters::ClusterParameters()
{
    m_gColdstartAttempts = 0;

    m_gCycleCountMax = 0;

    m_gdActionPointOffset = 0;

    m_gdDynamicSlotIdlePhase = 0;

    m_gdMiniSlot = 0;

    m_gdMiniSlotActionPointOffset = 0;

    m_gdStaticSlot = 0;

    m_gdSymbolWindow = 0;

    m_gdSymbolWindowActionPointOffset = 0;

    m_gdTSSTransmitter = 0;

    m_gdWakeupTxActive = 0;

    m_gdWakeupTxIdle = 0;

    m_gListenNoise = 0;

    m_gMacroPerCycle = 0;

    m_gMaxWithoutClockCorrectionFatal = 0;

    m_gMaxWithoutClockCorrectionPassive = 0;

    m_gNumberOfMiniSlots = 0;

    m_gNumberOfStaticSlots = 0;

    m_gPayloadLengthStatic = 0;

    m_gSyncFrameIDCountMax = 0;


}

ib::sim::fr::idl::ClusterParameters::~ClusterParameters()
{
}

ib::sim::fr::idl::ClusterParameters::ClusterParameters(const ClusterParameters &x)
{
    m_gColdstartAttempts = x.m_gColdstartAttempts;
    m_gCycleCountMax = x.m_gCycleCountMax;
    m_gdActionPointOffset = x.m_gdActionPointOffset;
    m_gdDynamicSlotIdlePhase = x.m_gdDynamicSlotIdlePhase;
    m_gdMiniSlot = x.m_gdMiniSlot;
    m_gdMiniSlotActionPointOffset = x.m_gdMiniSlotActionPointOffset;
    m_gdStaticSlot = x.m_gdStaticSlot;
    m_gdSymbolWindow = x.m_gdSymbolWindow;
    m_gdSymbolWindowActionPointOffset = x.m_gdSymbolWindowActionPointOffset;
    m_gdTSSTransmitter = x.m_gdTSSTransmitter;
    m_gdWakeupTxActive = x.m_gdWakeupTxActive;
    m_gdWakeupTxIdle = x.m_gdWakeupTxIdle;
    m_gListenNoise = x.m_gListenNoise;
    m_gMacroPerCycle = x.m_gMacroPerCycle;
    m_gMaxWithoutClockCorrectionFatal = x.m_gMaxWithoutClockCorrectionFatal;
    m_gMaxWithoutClockCorrectionPassive = x.m_gMaxWithoutClockCorrectionPassive;
    m_gNumberOfMiniSlots = x.m_gNumberOfMiniSlots;
    m_gNumberOfStaticSlots = x.m_gNumberOfStaticSlots;
    m_gPayloadLengthStatic = x.m_gPayloadLengthStatic;
    m_gSyncFrameIDCountMax = x.m_gSyncFrameIDCountMax;
}

ib::sim::fr::idl::ClusterParameters::ClusterParameters(ClusterParameters &&x)
{
    m_gColdstartAttempts = x.m_gColdstartAttempts;
    m_gCycleCountMax = x.m_gCycleCountMax;
    m_gdActionPointOffset = x.m_gdActionPointOffset;
    m_gdDynamicSlotIdlePhase = x.m_gdDynamicSlotIdlePhase;
    m_gdMiniSlot = x.m_gdMiniSlot;
    m_gdMiniSlotActionPointOffset = x.m_gdMiniSlotActionPointOffset;
    m_gdStaticSlot = x.m_gdStaticSlot;
    m_gdSymbolWindow = x.m_gdSymbolWindow;
    m_gdSymbolWindowActionPointOffset = x.m_gdSymbolWindowActionPointOffset;
    m_gdTSSTransmitter = x.m_gdTSSTransmitter;
    m_gdWakeupTxActive = x.m_gdWakeupTxActive;
    m_gdWakeupTxIdle = x.m_gdWakeupTxIdle;
    m_gListenNoise = x.m_gListenNoise;
    m_gMacroPerCycle = x.m_gMacroPerCycle;
    m_gMaxWithoutClockCorrectionFatal = x.m_gMaxWithoutClockCorrectionFatal;
    m_gMaxWithoutClockCorrectionPassive = x.m_gMaxWithoutClockCorrectionPassive;
    m_gNumberOfMiniSlots = x.m_gNumberOfMiniSlots;
    m_gNumberOfStaticSlots = x.m_gNumberOfStaticSlots;
    m_gPayloadLengthStatic = x.m_gPayloadLengthStatic;
    m_gSyncFrameIDCountMax = x.m_gSyncFrameIDCountMax;
}

ib::sim::fr::idl::ClusterParameters& ib::sim::fr::idl::ClusterParameters::operator=(const ClusterParameters &x)
{
    m_gColdstartAttempts = x.m_gColdstartAttempts;
    m_gCycleCountMax = x.m_gCycleCountMax;
    m_gdActionPointOffset = x.m_gdActionPointOffset;
    m_gdDynamicSlotIdlePhase = x.m_gdDynamicSlotIdlePhase;
    m_gdMiniSlot = x.m_gdMiniSlot;
    m_gdMiniSlotActionPointOffset = x.m_gdMiniSlotActionPointOffset;
    m_gdStaticSlot = x.m_gdStaticSlot;
    m_gdSymbolWindow = x.m_gdSymbolWindow;
    m_gdSymbolWindowActionPointOffset = x.m_gdSymbolWindowActionPointOffset;
    m_gdTSSTransmitter = x.m_gdTSSTransmitter;
    m_gdWakeupTxActive = x.m_gdWakeupTxActive;
    m_gdWakeupTxIdle = x.m_gdWakeupTxIdle;
    m_gListenNoise = x.m_gListenNoise;
    m_gMacroPerCycle = x.m_gMacroPerCycle;
    m_gMaxWithoutClockCorrectionFatal = x.m_gMaxWithoutClockCorrectionFatal;
    m_gMaxWithoutClockCorrectionPassive = x.m_gMaxWithoutClockCorrectionPassive;
    m_gNumberOfMiniSlots = x.m_gNumberOfMiniSlots;
    m_gNumberOfStaticSlots = x.m_gNumberOfStaticSlots;
    m_gPayloadLengthStatic = x.m_gPayloadLengthStatic;
    m_gSyncFrameIDCountMax = x.m_gSyncFrameIDCountMax;

    return *this;
}

ib::sim::fr::idl::ClusterParameters& ib::sim::fr::idl::ClusterParameters::operator=(ClusterParameters &&x)
{
    m_gColdstartAttempts = x.m_gColdstartAttempts;
    m_gCycleCountMax = x.m_gCycleCountMax;
    m_gdActionPointOffset = x.m_gdActionPointOffset;
    m_gdDynamicSlotIdlePhase = x.m_gdDynamicSlotIdlePhase;
    m_gdMiniSlot = x.m_gdMiniSlot;
    m_gdMiniSlotActionPointOffset = x.m_gdMiniSlotActionPointOffset;
    m_gdStaticSlot = x.m_gdStaticSlot;
    m_gdSymbolWindow = x.m_gdSymbolWindow;
    m_gdSymbolWindowActionPointOffset = x.m_gdSymbolWindowActionPointOffset;
    m_gdTSSTransmitter = x.m_gdTSSTransmitter;
    m_gdWakeupTxActive = x.m_gdWakeupTxActive;
    m_gdWakeupTxIdle = x.m_gdWakeupTxIdle;
    m_gListenNoise = x.m_gListenNoise;
    m_gMacroPerCycle = x.m_gMacroPerCycle;
    m_gMaxWithoutClockCorrectionFatal = x.m_gMaxWithoutClockCorrectionFatal;
    m_gMaxWithoutClockCorrectionPassive = x.m_gMaxWithoutClockCorrectionPassive;
    m_gNumberOfMiniSlots = x.m_gNumberOfMiniSlots;
    m_gNumberOfStaticSlots = x.m_gNumberOfStaticSlots;
    m_gPayloadLengthStatic = x.m_gPayloadLengthStatic;
    m_gSyncFrameIDCountMax = x.m_gSyncFrameIDCountMax;

    return *this;
}

size_t ib::sim::fr::idl::ClusterParameters::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::ClusterParameters::getCdrSerializedSize(const ib::sim::fr::idl::ClusterParameters& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::ClusterParameters::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_gColdstartAttempts;
    scdr << m_gCycleCountMax;
    scdr << m_gdActionPointOffset;
    scdr << m_gdDynamicSlotIdlePhase;
    scdr << m_gdMiniSlot;
    scdr << m_gdMiniSlotActionPointOffset;
    scdr << m_gdStaticSlot;
    scdr << m_gdSymbolWindow;
    scdr << m_gdSymbolWindowActionPointOffset;
    scdr << m_gdTSSTransmitter;
    scdr << m_gdWakeupTxActive;
    scdr << m_gdWakeupTxIdle;
    scdr << m_gListenNoise;
    scdr << m_gMacroPerCycle;
    scdr << m_gMaxWithoutClockCorrectionFatal;
    scdr << m_gMaxWithoutClockCorrectionPassive;
    scdr << m_gNumberOfMiniSlots;
    scdr << m_gNumberOfStaticSlots;
    scdr << m_gPayloadLengthStatic;
    scdr << m_gSyncFrameIDCountMax;
}

void ib::sim::fr::idl::ClusterParameters::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_gColdstartAttempts;
    dcdr >> m_gCycleCountMax;
    dcdr >> m_gdActionPointOffset;
    dcdr >> m_gdDynamicSlotIdlePhase;
    dcdr >> m_gdMiniSlot;
    dcdr >> m_gdMiniSlotActionPointOffset;
    dcdr >> m_gdStaticSlot;
    dcdr >> m_gdSymbolWindow;
    dcdr >> m_gdSymbolWindowActionPointOffset;
    dcdr >> m_gdTSSTransmitter;
    dcdr >> m_gdWakeupTxActive;
    dcdr >> m_gdWakeupTxIdle;
    dcdr >> m_gListenNoise;
    dcdr >> m_gMacroPerCycle;
    dcdr >> m_gMaxWithoutClockCorrectionFatal;
    dcdr >> m_gMaxWithoutClockCorrectionPassive;
    dcdr >> m_gNumberOfMiniSlots;
    dcdr >> m_gNumberOfStaticSlots;
    dcdr >> m_gPayloadLengthStatic;
    dcdr >> m_gSyncFrameIDCountMax;
}

size_t ib::sim::fr::idl::ClusterParameters::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





















    return current_align;
}

bool ib::sim::fr::idl::ClusterParameters::isKeyDefined()
{
    return false;
}

void ib::sim::fr::idl::ClusterParameters::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
}
ib::sim::fr::idl::NodeParameters::NodeParameters()
{
    m_pAllowHaltDueToClock = 0;

    m_pAllowPassiveToActive = 0;

    m_pChannels = ib::sim::fr::idl::None;

    m_pClusterDriftDamping = 0;

    m_pdAcceptedStartupRange = 0;

    m_pdListenTimeout = 0;

    m_pKeySlotId = 0;

    m_pKeySlotOnlyEnabled = 0;

    m_pKeySlotUsedForStartup = 0;

    m_pKeySlotUsedForSync = 0;

    m_pLatestTx = 0;

    m_pMacroInitialOffsetA = 0;

    m_pMacroInitialOffsetB = 0;

    m_pMicroInitialOffsetA = 0;

    m_pMicroInitialOffsetB = 0;

    m_pMicroPerCycle = 0;

    m_pOffsetCorrectionOut = 0;

    m_pOffsetCorrectionStart = 0;

    m_pRateCorrectionOut = 0;

    m_pWakeupChannel = ib::sim::fr::idl::None;

    m_pWakeupPattern = 0;

    m_pdMicrotick = ib::sim::fr::idl::T12_5NS;

    m_pSamplesPerMicrotick = 0;


}

ib::sim::fr::idl::NodeParameters::~NodeParameters()
{
}

ib::sim::fr::idl::NodeParameters::NodeParameters(const NodeParameters &x)
{
    m_pAllowHaltDueToClock = x.m_pAllowHaltDueToClock;
    m_pAllowPassiveToActive = x.m_pAllowPassiveToActive;
    m_pChannels = x.m_pChannels;
    m_pClusterDriftDamping = x.m_pClusterDriftDamping;
    m_pdAcceptedStartupRange = x.m_pdAcceptedStartupRange;
    m_pdListenTimeout = x.m_pdListenTimeout;
    m_pKeySlotId = x.m_pKeySlotId;
    m_pKeySlotOnlyEnabled = x.m_pKeySlotOnlyEnabled;
    m_pKeySlotUsedForStartup = x.m_pKeySlotUsedForStartup;
    m_pKeySlotUsedForSync = x.m_pKeySlotUsedForSync;
    m_pLatestTx = x.m_pLatestTx;
    m_pMacroInitialOffsetA = x.m_pMacroInitialOffsetA;
    m_pMacroInitialOffsetB = x.m_pMacroInitialOffsetB;
    m_pMicroInitialOffsetA = x.m_pMicroInitialOffsetA;
    m_pMicroInitialOffsetB = x.m_pMicroInitialOffsetB;
    m_pMicroPerCycle = x.m_pMicroPerCycle;
    m_pOffsetCorrectionOut = x.m_pOffsetCorrectionOut;
    m_pOffsetCorrectionStart = x.m_pOffsetCorrectionStart;
    m_pRateCorrectionOut = x.m_pRateCorrectionOut;
    m_pWakeupChannel = x.m_pWakeupChannel;
    m_pWakeupPattern = x.m_pWakeupPattern;
    m_pdMicrotick = x.m_pdMicrotick;
    m_pSamplesPerMicrotick = x.m_pSamplesPerMicrotick;
}

ib::sim::fr::idl::NodeParameters::NodeParameters(NodeParameters &&x)
{
    m_pAllowHaltDueToClock = x.m_pAllowHaltDueToClock;
    m_pAllowPassiveToActive = x.m_pAllowPassiveToActive;
    m_pChannels = x.m_pChannels;
    m_pClusterDriftDamping = x.m_pClusterDriftDamping;
    m_pdAcceptedStartupRange = x.m_pdAcceptedStartupRange;
    m_pdListenTimeout = x.m_pdListenTimeout;
    m_pKeySlotId = x.m_pKeySlotId;
    m_pKeySlotOnlyEnabled = x.m_pKeySlotOnlyEnabled;
    m_pKeySlotUsedForStartup = x.m_pKeySlotUsedForStartup;
    m_pKeySlotUsedForSync = x.m_pKeySlotUsedForSync;
    m_pLatestTx = x.m_pLatestTx;
    m_pMacroInitialOffsetA = x.m_pMacroInitialOffsetA;
    m_pMacroInitialOffsetB = x.m_pMacroInitialOffsetB;
    m_pMicroInitialOffsetA = x.m_pMicroInitialOffsetA;
    m_pMicroInitialOffsetB = x.m_pMicroInitialOffsetB;
    m_pMicroPerCycle = x.m_pMicroPerCycle;
    m_pOffsetCorrectionOut = x.m_pOffsetCorrectionOut;
    m_pOffsetCorrectionStart = x.m_pOffsetCorrectionStart;
    m_pRateCorrectionOut = x.m_pRateCorrectionOut;
    m_pWakeupChannel = x.m_pWakeupChannel;
    m_pWakeupPattern = x.m_pWakeupPattern;
    m_pdMicrotick = x.m_pdMicrotick;
    m_pSamplesPerMicrotick = x.m_pSamplesPerMicrotick;
}

ib::sim::fr::idl::NodeParameters& ib::sim::fr::idl::NodeParameters::operator=(const NodeParameters &x)
{
    m_pAllowHaltDueToClock = x.m_pAllowHaltDueToClock;
    m_pAllowPassiveToActive = x.m_pAllowPassiveToActive;
    m_pChannels = x.m_pChannels;
    m_pClusterDriftDamping = x.m_pClusterDriftDamping;
    m_pdAcceptedStartupRange = x.m_pdAcceptedStartupRange;
    m_pdListenTimeout = x.m_pdListenTimeout;
    m_pKeySlotId = x.m_pKeySlotId;
    m_pKeySlotOnlyEnabled = x.m_pKeySlotOnlyEnabled;
    m_pKeySlotUsedForStartup = x.m_pKeySlotUsedForStartup;
    m_pKeySlotUsedForSync = x.m_pKeySlotUsedForSync;
    m_pLatestTx = x.m_pLatestTx;
    m_pMacroInitialOffsetA = x.m_pMacroInitialOffsetA;
    m_pMacroInitialOffsetB = x.m_pMacroInitialOffsetB;
    m_pMicroInitialOffsetA = x.m_pMicroInitialOffsetA;
    m_pMicroInitialOffsetB = x.m_pMicroInitialOffsetB;
    m_pMicroPerCycle = x.m_pMicroPerCycle;
    m_pOffsetCorrectionOut = x.m_pOffsetCorrectionOut;
    m_pOffsetCorrectionStart = x.m_pOffsetCorrectionStart;
    m_pRateCorrectionOut = x.m_pRateCorrectionOut;
    m_pWakeupChannel = x.m_pWakeupChannel;
    m_pWakeupPattern = x.m_pWakeupPattern;
    m_pdMicrotick = x.m_pdMicrotick;
    m_pSamplesPerMicrotick = x.m_pSamplesPerMicrotick;

    return *this;
}

ib::sim::fr::idl::NodeParameters& ib::sim::fr::idl::NodeParameters::operator=(NodeParameters &&x)
{
    m_pAllowHaltDueToClock = x.m_pAllowHaltDueToClock;
    m_pAllowPassiveToActive = x.m_pAllowPassiveToActive;
    m_pChannels = x.m_pChannels;
    m_pClusterDriftDamping = x.m_pClusterDriftDamping;
    m_pdAcceptedStartupRange = x.m_pdAcceptedStartupRange;
    m_pdListenTimeout = x.m_pdListenTimeout;
    m_pKeySlotId = x.m_pKeySlotId;
    m_pKeySlotOnlyEnabled = x.m_pKeySlotOnlyEnabled;
    m_pKeySlotUsedForStartup = x.m_pKeySlotUsedForStartup;
    m_pKeySlotUsedForSync = x.m_pKeySlotUsedForSync;
    m_pLatestTx = x.m_pLatestTx;
    m_pMacroInitialOffsetA = x.m_pMacroInitialOffsetA;
    m_pMacroInitialOffsetB = x.m_pMacroInitialOffsetB;
    m_pMicroInitialOffsetA = x.m_pMicroInitialOffsetA;
    m_pMicroInitialOffsetB = x.m_pMicroInitialOffsetB;
    m_pMicroPerCycle = x.m_pMicroPerCycle;
    m_pOffsetCorrectionOut = x.m_pOffsetCorrectionOut;
    m_pOffsetCorrectionStart = x.m_pOffsetCorrectionStart;
    m_pRateCorrectionOut = x.m_pRateCorrectionOut;
    m_pWakeupChannel = x.m_pWakeupChannel;
    m_pWakeupPattern = x.m_pWakeupPattern;
    m_pdMicrotick = x.m_pdMicrotick;
    m_pSamplesPerMicrotick = x.m_pSamplesPerMicrotick;

    return *this;
}

size_t ib::sim::fr::idl::NodeParameters::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::NodeParameters::getCdrSerializedSize(const ib::sim::fr::idl::NodeParameters& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::NodeParameters::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_pAllowHaltDueToClock;
    scdr << m_pAllowPassiveToActive;
    scdr << (uint32_t)m_pChannels;
    scdr << m_pClusterDriftDamping;
    scdr << m_pdAcceptedStartupRange;
    scdr << m_pdListenTimeout;
    scdr << m_pKeySlotId;
    scdr << m_pKeySlotOnlyEnabled;
    scdr << m_pKeySlotUsedForStartup;
    scdr << m_pKeySlotUsedForSync;
    scdr << m_pLatestTx;
    scdr << m_pMacroInitialOffsetA;
    scdr << m_pMacroInitialOffsetB;
    scdr << m_pMicroInitialOffsetA;
    scdr << m_pMicroInitialOffsetB;
    scdr << m_pMicroPerCycle;
    scdr << m_pOffsetCorrectionOut;
    scdr << m_pOffsetCorrectionStart;
    scdr << m_pRateCorrectionOut;
    scdr << (uint32_t)m_pWakeupChannel;
    scdr << m_pWakeupPattern;
    scdr << (uint32_t)m_pdMicrotick;
    scdr << m_pSamplesPerMicrotick;
}

void ib::sim::fr::idl::NodeParameters::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_pAllowHaltDueToClock;
    dcdr >> m_pAllowPassiveToActive;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_pChannels = (ib::sim::fr::idl::Channel)enum_value;
    }
    dcdr >> m_pClusterDriftDamping;
    dcdr >> m_pdAcceptedStartupRange;
    dcdr >> m_pdListenTimeout;
    dcdr >> m_pKeySlotId;
    dcdr >> m_pKeySlotOnlyEnabled;
    dcdr >> m_pKeySlotUsedForStartup;
    dcdr >> m_pKeySlotUsedForSync;
    dcdr >> m_pLatestTx;
    dcdr >> m_pMacroInitialOffsetA;
    dcdr >> m_pMacroInitialOffsetB;
    dcdr >> m_pMicroInitialOffsetA;
    dcdr >> m_pMicroInitialOffsetB;
    dcdr >> m_pMicroPerCycle;
    dcdr >> m_pOffsetCorrectionOut;
    dcdr >> m_pOffsetCorrectionStart;
    dcdr >> m_pRateCorrectionOut;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_pWakeupChannel = (ib::sim::fr::idl::Channel)enum_value;
    }
    dcdr >> m_pWakeupPattern;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_pdMicrotick = (ib::sim::fr::idl::ClockPeriod)enum_value;
    }
    dcdr >> m_pSamplesPerMicrotick;
}

size_t ib::sim::fr::idl::NodeParameters::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
























    return current_align;
}

bool ib::sim::fr::idl::NodeParameters::isKeyDefined()
{
    return false;
}

void ib::sim::fr::idl::NodeParameters::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
}

ib::sim::fr::idl::TxBufferConfig::TxBufferConfig()
{
    m_channels = ib::sim::fr::idl::None;

    m_slotId = 0;

    m_offset = 0;

    m_repetition = 0;

    m_hasPayloadPreambleIndicator = false;

    m_headerCrc = 0;

    m_transmissionMode = ib::sim::fr::idl::SingleShot;


}

ib::sim::fr::idl::TxBufferConfig::~TxBufferConfig()
{
}

ib::sim::fr::idl::TxBufferConfig::TxBufferConfig(const TxBufferConfig &x)
{
    m_channels = x.m_channels;
    m_slotId = x.m_slotId;
    m_offset = x.m_offset;
    m_repetition = x.m_repetition;
    m_hasPayloadPreambleIndicator = x.m_hasPayloadPreambleIndicator;
    m_headerCrc = x.m_headerCrc;
    m_transmissionMode = x.m_transmissionMode;
}

ib::sim::fr::idl::TxBufferConfig::TxBufferConfig(TxBufferConfig &&x)
{
    m_channels = x.m_channels;
    m_slotId = x.m_slotId;
    m_offset = x.m_offset;
    m_repetition = x.m_repetition;
    m_hasPayloadPreambleIndicator = x.m_hasPayloadPreambleIndicator;
    m_headerCrc = x.m_headerCrc;
    m_transmissionMode = x.m_transmissionMode;
}

ib::sim::fr::idl::TxBufferConfig& ib::sim::fr::idl::TxBufferConfig::operator=(const TxBufferConfig &x)
{
    m_channels = x.m_channels;
    m_slotId = x.m_slotId;
    m_offset = x.m_offset;
    m_repetition = x.m_repetition;
    m_hasPayloadPreambleIndicator = x.m_hasPayloadPreambleIndicator;
    m_headerCrc = x.m_headerCrc;
    m_transmissionMode = x.m_transmissionMode;

    return *this;
}

ib::sim::fr::idl::TxBufferConfig& ib::sim::fr::idl::TxBufferConfig::operator=(TxBufferConfig &&x)
{
    m_channels = x.m_channels;
    m_slotId = x.m_slotId;
    m_offset = x.m_offset;
    m_repetition = x.m_repetition;
    m_hasPayloadPreambleIndicator = x.m_hasPayloadPreambleIndicator;
    m_headerCrc = x.m_headerCrc;
    m_transmissionMode = x.m_transmissionMode;

    return *this;
}

size_t ib::sim::fr::idl::TxBufferConfig::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::TxBufferConfig::getCdrSerializedSize(const ib::sim::fr::idl::TxBufferConfig& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::TxBufferConfig::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << (uint32_t)m_channels;
    scdr << m_slotId;
    scdr << m_offset;
    scdr << m_repetition;
    scdr << m_hasPayloadPreambleIndicator;
    scdr << m_headerCrc;
    scdr << (uint32_t)m_transmissionMode;
}

void ib::sim::fr::idl::TxBufferConfig::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_channels = (ib::sim::fr::idl::Channel)enum_value;
    }
    dcdr >> m_slotId;
    dcdr >> m_offset;
    dcdr >> m_repetition;
    dcdr >> m_hasPayloadPreambleIndicator;
    dcdr >> m_headerCrc;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_transmissionMode = (ib::sim::fr::idl::TransmissionMode)enum_value;
    }
}

size_t ib::sim::fr::idl::TxBufferConfig::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            








    return current_align;
}

bool ib::sim::fr::idl::TxBufferConfig::isKeyDefined()
{
    return false;
}

void ib::sim::fr::idl::TxBufferConfig::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
}
ib::sim::fr::idl::ControllerConfig::ControllerConfig()
{





}

ib::sim::fr::idl::ControllerConfig::~ControllerConfig()
{
}

ib::sim::fr::idl::ControllerConfig::ControllerConfig(const ControllerConfig &x)
{
    m_senderAddr = x.m_senderAddr;
    m_clusterParams = x.m_clusterParams;
    m_nodeParams = x.m_nodeParams;
    m_bufferConfigs = x.m_bufferConfigs;
}

ib::sim::fr::idl::ControllerConfig::ControllerConfig(ControllerConfig &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_clusterParams = std::move(x.m_clusterParams);
    m_nodeParams = std::move(x.m_nodeParams);
    m_bufferConfigs = std::move(x.m_bufferConfigs);
}

ib::sim::fr::idl::ControllerConfig& ib::sim::fr::idl::ControllerConfig::operator=(const ControllerConfig &x)
{
    m_senderAddr = x.m_senderAddr;
    m_clusterParams = x.m_clusterParams;
    m_nodeParams = x.m_nodeParams;
    m_bufferConfigs = x.m_bufferConfigs;

    return *this;
}

ib::sim::fr::idl::ControllerConfig& ib::sim::fr::idl::ControllerConfig::operator=(ControllerConfig &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_clusterParams = std::move(x.m_clusterParams);
    m_nodeParams = std::move(x.m_nodeParams);
    m_bufferConfigs = std::move(x.m_bufferConfigs);

    return *this;
}

size_t ib::sim::fr::idl::ControllerConfig::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ib::sim::fr::idl::ClusterParameters::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ib::sim::fr::idl::NodeParameters::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += ib::sim::fr::idl::TxBufferConfig::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::ControllerConfig::getCdrSerializedSize(const ib::sim::fr::idl::ControllerConfig& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += ib::sim::fr::idl::ClusterParameters::getCdrSerializedSize(data.clusterParams(), current_alignment);
    current_alignment += ib::sim::fr::idl::NodeParameters::getCdrSerializedSize(data.nodeParams(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.bufferConfigs().size(); ++a)
    {
        current_alignment += ib::sim::fr::idl::TxBufferConfig::getCdrSerializedSize(data.bufferConfigs().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::ControllerConfig::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_clusterParams;
    scdr << m_nodeParams;
    scdr << m_bufferConfigs;
}

void ib::sim::fr::idl::ControllerConfig::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_clusterParams;
    dcdr >> m_nodeParams;
    dcdr >> m_bufferConfigs;
}

size_t ib::sim::fr::idl::ControllerConfig::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 




    return current_align;
}

bool ib::sim::fr::idl::ControllerConfig::isKeyDefined()
{
    return true;
}

void ib::sim::fr::idl::ControllerConfig::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
}
ib::sim::fr::idl::TxBufferConfigUpdate::TxBufferConfigUpdate()
{

    m_txBufferIndex = 0;



}

ib::sim::fr::idl::TxBufferConfigUpdate::~TxBufferConfigUpdate()
{
}

ib::sim::fr::idl::TxBufferConfigUpdate::TxBufferConfigUpdate(const TxBufferConfigUpdate &x)
{
    m_senderAddr = x.m_senderAddr;
    m_txBufferIndex = x.m_txBufferIndex;
    m_txBufferConfig = x.m_txBufferConfig;
}

ib::sim::fr::idl::TxBufferConfigUpdate::TxBufferConfigUpdate(TxBufferConfigUpdate &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_txBufferIndex = x.m_txBufferIndex;
    m_txBufferConfig = std::move(x.m_txBufferConfig);
}

ib::sim::fr::idl::TxBufferConfigUpdate& ib::sim::fr::idl::TxBufferConfigUpdate::operator=(const TxBufferConfigUpdate &x)
{
    m_senderAddr = x.m_senderAddr;
    m_txBufferIndex = x.m_txBufferIndex;
    m_txBufferConfig = x.m_txBufferConfig;

    return *this;
}

ib::sim::fr::idl::TxBufferConfigUpdate& ib::sim::fr::idl::TxBufferConfigUpdate::operator=(TxBufferConfigUpdate &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_txBufferIndex = x.m_txBufferIndex;
    m_txBufferConfig = std::move(x.m_txBufferConfig);

    return *this;
}

size_t ib::sim::fr::idl::TxBufferConfigUpdate::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += ib::sim::fr::idl::TxBufferConfig::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::TxBufferConfigUpdate::getCdrSerializedSize(const ib::sim::fr::idl::TxBufferConfigUpdate& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += ib::sim::fr::idl::TxBufferConfig::getCdrSerializedSize(data.txBufferConfig(), current_alignment);

    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::TxBufferConfigUpdate::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_txBufferIndex;
    scdr << m_txBufferConfig;
}

void ib::sim::fr::idl::TxBufferConfigUpdate::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_txBufferIndex;
    dcdr >> m_txBufferConfig;
}

size_t ib::sim::fr::idl::TxBufferConfigUpdate::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 



    return current_align;
}

bool ib::sim::fr::idl::TxBufferConfigUpdate::isKeyDefined()
{
    return true;
}

void ib::sim::fr::idl::TxBufferConfigUpdate::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
}
ib::sim::fr::idl::TxBufferUpdate::TxBufferUpdate()
{

    m_txBufferIndex = 0;

    m_payloadDataValid = false;



}

ib::sim::fr::idl::TxBufferUpdate::~TxBufferUpdate()
{
}

ib::sim::fr::idl::TxBufferUpdate::TxBufferUpdate(const TxBufferUpdate &x)
{
    m_senderAddr = x.m_senderAddr;
    m_txBufferIndex = x.m_txBufferIndex;
    m_payloadDataValid = x.m_payloadDataValid;
    m_payload = x.m_payload;
}

ib::sim::fr::idl::TxBufferUpdate::TxBufferUpdate(TxBufferUpdate &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_txBufferIndex = x.m_txBufferIndex;
    m_payloadDataValid = x.m_payloadDataValid;
    m_payload = std::move(x.m_payload);
}

ib::sim::fr::idl::TxBufferUpdate& ib::sim::fr::idl::TxBufferUpdate::operator=(const TxBufferUpdate &x)
{
    m_senderAddr = x.m_senderAddr;
    m_txBufferIndex = x.m_txBufferIndex;
    m_payloadDataValid = x.m_payloadDataValid;
    m_payload = x.m_payload;

    return *this;
}

ib::sim::fr::idl::TxBufferUpdate& ib::sim::fr::idl::TxBufferUpdate::operator=(TxBufferUpdate &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_txBufferIndex = x.m_txBufferIndex;
    m_payloadDataValid = x.m_payloadDataValid;
    m_payload = std::move(x.m_payload);

    return *this;
}

size_t ib::sim::fr::idl::TxBufferUpdate::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::TxBufferUpdate::getCdrSerializedSize(const ib::sim::fr::idl::TxBufferUpdate& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (data.payload().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::TxBufferUpdate::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_txBufferIndex;
    scdr << m_payloadDataValid;
    scdr << m_payload;
}

void ib::sim::fr::idl::TxBufferUpdate::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_txBufferIndex;
    dcdr >> m_payloadDataValid;
    dcdr >> m_payload;
}

size_t ib::sim::fr::idl::TxBufferUpdate::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 




    return current_align;
}

bool ib::sim::fr::idl::TxBufferUpdate::isKeyDefined()
{
    return true;
}

void ib::sim::fr::idl::TxBufferUpdate::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
}

ib::sim::fr::idl::HostCommand::HostCommand()
{

    m_command = ib::sim::fr::idl::RUN;


}

ib::sim::fr::idl::HostCommand::~HostCommand()
{
}

ib::sim::fr::idl::HostCommand::HostCommand(const HostCommand &x)
{
    m_senderAddr = x.m_senderAddr;
    m_command = x.m_command;
}

ib::sim::fr::idl::HostCommand::HostCommand(HostCommand &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_command = x.m_command;
}

ib::sim::fr::idl::HostCommand& ib::sim::fr::idl::HostCommand::operator=(const HostCommand &x)
{
    m_senderAddr = x.m_senderAddr;
    m_command = x.m_command;

    return *this;
}

ib::sim::fr::idl::HostCommand& ib::sim::fr::idl::HostCommand::operator=(HostCommand &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_command = x.m_command;

    return *this;
}

size_t ib::sim::fr::idl::HostCommand::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::HostCommand::getCdrSerializedSize(const ib::sim::fr::idl::HostCommand& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::HostCommand::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << (uint32_t)m_command;
}

void ib::sim::fr::idl::HostCommand::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_command = (ib::sim::fr::idl::ChiCommand)enum_value;
    }
}

size_t ib::sim::fr::idl::HostCommand::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 


    return current_align;
}

bool ib::sim::fr::idl::HostCommand::isKeyDefined()
{
    return true;
}

void ib::sim::fr::idl::HostCommand::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
}
ib::sim::fr::idl::Header::Header()
{
    m_flags = 0;

    m_frameId = 0;

    m_payloadLength = 0;

    m_headerCrc = 0;

    m_cycleCount = 0;


}

ib::sim::fr::idl::Header::~Header()
{
}

ib::sim::fr::idl::Header::Header(const Header &x)
{
    m_flags = x.m_flags;
    m_frameId = x.m_frameId;
    m_payloadLength = x.m_payloadLength;
    m_headerCrc = x.m_headerCrc;
    m_cycleCount = x.m_cycleCount;
}

ib::sim::fr::idl::Header::Header(Header &&x)
{
    m_flags = x.m_flags;
    m_frameId = x.m_frameId;
    m_payloadLength = x.m_payloadLength;
    m_headerCrc = x.m_headerCrc;
    m_cycleCount = x.m_cycleCount;
}

ib::sim::fr::idl::Header& ib::sim::fr::idl::Header::operator=(const Header &x)
{
    m_flags = x.m_flags;
    m_frameId = x.m_frameId;
    m_payloadLength = x.m_payloadLength;
    m_headerCrc = x.m_headerCrc;
    m_cycleCount = x.m_cycleCount;

    return *this;
}

ib::sim::fr::idl::Header& ib::sim::fr::idl::Header::operator=(Header &&x)
{
    m_flags = x.m_flags;
    m_frameId = x.m_frameId;
    m_payloadLength = x.m_payloadLength;
    m_headerCrc = x.m_headerCrc;
    m_cycleCount = x.m_cycleCount;

    return *this;
}

size_t ib::sim::fr::idl::Header::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::Header::getCdrSerializedSize(const ib::sim::fr::idl::Header& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::Header::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_flags;
    scdr << m_frameId;
    scdr << m_payloadLength;
    scdr << m_headerCrc;
    scdr << m_cycleCount;
}

void ib::sim::fr::idl::Header::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_flags;
    dcdr >> m_frameId;
    dcdr >> m_payloadLength;
    dcdr >> m_headerCrc;
    dcdr >> m_cycleCount;
}

size_t ib::sim::fr::idl::Header::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool ib::sim::fr::idl::Header::isKeyDefined()
{
    return false;
}

void ib::sim::fr::idl::Header::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}
ib::sim::fr::idl::Frame::Frame()
{



}

ib::sim::fr::idl::Frame::~Frame()
{
}

ib::sim::fr::idl::Frame::Frame(const Frame &x)
{
    m_header = x.m_header;
    m_payload = x.m_payload;
}

ib::sim::fr::idl::Frame::Frame(Frame &&x)
{
    m_header = std::move(x.m_header);
    m_payload = std::move(x.m_payload);
}

ib::sim::fr::idl::Frame& ib::sim::fr::idl::Frame::operator=(const Frame &x)
{
    m_header = x.m_header;
    m_payload = x.m_payload;

    return *this;
}

ib::sim::fr::idl::Frame& ib::sim::fr::idl::Frame::operator=(Frame &&x)
{
    m_header = std::move(x.m_header);
    m_payload = std::move(x.m_payload);

    return *this;
}

size_t ib::sim::fr::idl::Frame::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::sim::fr::idl::Header::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (254 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::Frame::getCdrSerializedSize(const ib::sim::fr::idl::Frame& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::sim::fr::idl::Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (data.payload().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::Frame::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_header;
    scdr << m_payload;
}

void ib::sim::fr::idl::Frame::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_header;
    dcdr >> m_payload;
}

size_t ib::sim::fr::idl::Frame::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool ib::sim::fr::idl::Frame::isKeyDefined()
{
    return false;
}

void ib::sim::fr::idl::Frame::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}
ib::sim::fr::idl::FrMessage::FrMessage()
{

    m_timeNs = 0;

    m_channel = ib::sim::fr::idl::None;



}

ib::sim::fr::idl::FrMessage::~FrMessage()
{
}

ib::sim::fr::idl::FrMessage::FrMessage(const FrMessage &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timeNs = x.m_timeNs;
    m_channel = x.m_channel;
    m_frame = x.m_frame;
}

ib::sim::fr::idl::FrMessage::FrMessage(FrMessage &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timeNs = x.m_timeNs;
    m_channel = x.m_channel;
    m_frame = std::move(x.m_frame);
}

ib::sim::fr::idl::FrMessage& ib::sim::fr::idl::FrMessage::operator=(const FrMessage &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timeNs = x.m_timeNs;
    m_channel = x.m_channel;
    m_frame = x.m_frame;

    return *this;
}

ib::sim::fr::idl::FrMessage& ib::sim::fr::idl::FrMessage::operator=(FrMessage &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timeNs = x.m_timeNs;
    m_channel = x.m_channel;
    m_frame = std::move(x.m_frame);

    return *this;
}

size_t ib::sim::fr::idl::FrMessage::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ib::sim::fr::idl::Frame::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::FrMessage::getCdrSerializedSize(const ib::sim::fr::idl::FrMessage& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ib::sim::fr::idl::Frame::getCdrSerializedSize(data.frame(), current_alignment);

    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::FrMessage::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_timeNs;
    scdr << (uint32_t)m_channel;
    scdr << m_frame;
}

void ib::sim::fr::idl::FrMessage::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_timeNs;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_channel = (ib::sim::fr::idl::Channel)enum_value;
    }
    dcdr >> m_frame;
}

size_t ib::sim::fr::idl::FrMessage::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 




    return current_align;
}

bool ib::sim::fr::idl::FrMessage::isKeyDefined()
{
    return true;
}

void ib::sim::fr::idl::FrMessage::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
}
ib::sim::fr::idl::FrMessageAck::FrMessageAck()
{

    m_timeNs = 0;

    m_txBufferIndex = 0;

    m_channel = ib::sim::fr::idl::None;



}

ib::sim::fr::idl::FrMessageAck::~FrMessageAck()
{
}

ib::sim::fr::idl::FrMessageAck::FrMessageAck(const FrMessageAck &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timeNs = x.m_timeNs;
    m_txBufferIndex = x.m_txBufferIndex;
    m_channel = x.m_channel;
    m_frame = x.m_frame;
}

ib::sim::fr::idl::FrMessageAck::FrMessageAck(FrMessageAck &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timeNs = x.m_timeNs;
    m_txBufferIndex = x.m_txBufferIndex;
    m_channel = x.m_channel;
    m_frame = std::move(x.m_frame);
}

ib::sim::fr::idl::FrMessageAck& ib::sim::fr::idl::FrMessageAck::operator=(const FrMessageAck &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timeNs = x.m_timeNs;
    m_txBufferIndex = x.m_txBufferIndex;
    m_channel = x.m_channel;
    m_frame = x.m_frame;

    return *this;
}

ib::sim::fr::idl::FrMessageAck& ib::sim::fr::idl::FrMessageAck::operator=(FrMessageAck &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timeNs = x.m_timeNs;
    m_txBufferIndex = x.m_txBufferIndex;
    m_channel = x.m_channel;
    m_frame = std::move(x.m_frame);

    return *this;
}

size_t ib::sim::fr::idl::FrMessageAck::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ib::sim::fr::idl::Frame::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::FrMessageAck::getCdrSerializedSize(const ib::sim::fr::idl::FrMessageAck& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += ib::sim::fr::idl::Frame::getCdrSerializedSize(data.frame(), current_alignment);

    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::FrMessageAck::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_timeNs;
    scdr << m_txBufferIndex;
    scdr << (uint32_t)m_channel;
    scdr << m_frame;
}

void ib::sim::fr::idl::FrMessageAck::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_timeNs;
    dcdr >> m_txBufferIndex;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_channel = (ib::sim::fr::idl::Channel)enum_value;
    }
    dcdr >> m_frame;
}

size_t ib::sim::fr::idl::FrMessageAck::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 





    return current_align;
}

bool ib::sim::fr::idl::FrMessageAck::isKeyDefined()
{
    return true;
}

void ib::sim::fr::idl::FrMessageAck::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
	 
}

ib::sim::fr::idl::FrSymbol::FrSymbol()
{

    m_timeNs = 0;

    m_channel = ib::sim::fr::idl::None;

    m_pattern = ib::sim::fr::idl::CasMts;


}

ib::sim::fr::idl::FrSymbol::~FrSymbol()
{
}

ib::sim::fr::idl::FrSymbol::FrSymbol(const FrSymbol &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timeNs = x.m_timeNs;
    m_channel = x.m_channel;
    m_pattern = x.m_pattern;
}

ib::sim::fr::idl::FrSymbol::FrSymbol(FrSymbol &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timeNs = x.m_timeNs;
    m_channel = x.m_channel;
    m_pattern = x.m_pattern;
}

ib::sim::fr::idl::FrSymbol& ib::sim::fr::idl::FrSymbol::operator=(const FrSymbol &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timeNs = x.m_timeNs;
    m_channel = x.m_channel;
    m_pattern = x.m_pattern;

    return *this;
}

ib::sim::fr::idl::FrSymbol& ib::sim::fr::idl::FrSymbol::operator=(FrSymbol &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timeNs = x.m_timeNs;
    m_channel = x.m_channel;
    m_pattern = x.m_pattern;

    return *this;
}

size_t ib::sim::fr::idl::FrSymbol::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::FrSymbol::getCdrSerializedSize(const ib::sim::fr::idl::FrSymbol& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::FrSymbol::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_timeNs;
    scdr << (uint32_t)m_channel;
    scdr << (uint32_t)m_pattern;
}

void ib::sim::fr::idl::FrSymbol::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_timeNs;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_channel = (ib::sim::fr::idl::Channel)enum_value;
    }
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_pattern = (ib::sim::fr::idl::SymbolPattern)enum_value;
    }
}

size_t ib::sim::fr::idl::FrSymbol::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 




    return current_align;
}

bool ib::sim::fr::idl::FrSymbol::isKeyDefined()
{
    return true;
}

void ib::sim::fr::idl::FrSymbol::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
	 
}
ib::sim::fr::idl::FrSymbolAck::FrSymbolAck()
{



}

ib::sim::fr::idl::FrSymbolAck::~FrSymbolAck()
{
}

ib::sim::fr::idl::FrSymbolAck::FrSymbolAck(const FrSymbolAck &x)
{
    m_senderAddr = x.m_senderAddr;
    m_symbol = x.m_symbol;
}

ib::sim::fr::idl::FrSymbolAck::FrSymbolAck(FrSymbolAck &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_symbol = std::move(x.m_symbol);
}

ib::sim::fr::idl::FrSymbolAck& ib::sim::fr::idl::FrSymbolAck::operator=(const FrSymbolAck &x)
{
    m_senderAddr = x.m_senderAddr;
    m_symbol = x.m_symbol;

    return *this;
}

ib::sim::fr::idl::FrSymbolAck& ib::sim::fr::idl::FrSymbolAck::operator=(FrSymbolAck &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_symbol = std::move(x.m_symbol);

    return *this;
}

size_t ib::sim::fr::idl::FrSymbolAck::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ib::sim::fr::idl::FrSymbol::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::FrSymbolAck::getCdrSerializedSize(const ib::sim::fr::idl::FrSymbolAck& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += ib::sim::fr::idl::FrSymbol::getCdrSerializedSize(data.symbol(), current_alignment);

    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::FrSymbolAck::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_symbol;
}

void ib::sim::fr::idl::FrSymbolAck::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_symbol;
}

size_t ib::sim::fr::idl::FrSymbolAck::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 


    return current_align;
}

bool ib::sim::fr::idl::FrSymbolAck::isKeyDefined()
{
    return true;
}

void ib::sim::fr::idl::FrSymbolAck::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
}
ib::sim::fr::idl::CycleStart::CycleStart()
{

    m_timeNs = 0;

    m_cycleCounter = 0;


}

ib::sim::fr::idl::CycleStart::~CycleStart()
{
}

ib::sim::fr::idl::CycleStart::CycleStart(const CycleStart &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timeNs = x.m_timeNs;
    m_cycleCounter = x.m_cycleCounter;
}

ib::sim::fr::idl::CycleStart::CycleStart(CycleStart &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timeNs = x.m_timeNs;
    m_cycleCounter = x.m_cycleCounter;
}

ib::sim::fr::idl::CycleStart& ib::sim::fr::idl::CycleStart::operator=(const CycleStart &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timeNs = x.m_timeNs;
    m_cycleCounter = x.m_cycleCounter;

    return *this;
}

ib::sim::fr::idl::CycleStart& ib::sim::fr::idl::CycleStart::operator=(CycleStart &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timeNs = x.m_timeNs;
    m_cycleCounter = x.m_cycleCounter;

    return *this;
}

size_t ib::sim::fr::idl::CycleStart::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::CycleStart::getCdrSerializedSize(const ib::sim::fr::idl::CycleStart& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::CycleStart::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_timeNs;
    scdr << m_cycleCounter;
}

void ib::sim::fr::idl::CycleStart::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_timeNs;
    dcdr >> m_cycleCounter;
}

size_t ib::sim::fr::idl::CycleStart::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 



    return current_align;
}

bool ib::sim::fr::idl::CycleStart::isKeyDefined()
{
    return true;
}

void ib::sim::fr::idl::CycleStart::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
}

ib::sim::fr::idl::ControllerStatus::ControllerStatus()
{

    m_timeNs = 0;

    m_pocState = ib::sim::fr::idl::DefaultConfig;


}

ib::sim::fr::idl::ControllerStatus::~ControllerStatus()
{
}

ib::sim::fr::idl::ControllerStatus::ControllerStatus(const ControllerStatus &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timeNs = x.m_timeNs;
    m_pocState = x.m_pocState;
}

ib::sim::fr::idl::ControllerStatus::ControllerStatus(ControllerStatus &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timeNs = x.m_timeNs;
    m_pocState = x.m_pocState;
}

ib::sim::fr::idl::ControllerStatus& ib::sim::fr::idl::ControllerStatus::operator=(const ControllerStatus &x)
{
    m_senderAddr = x.m_senderAddr;
    m_timeNs = x.m_timeNs;
    m_pocState = x.m_pocState;

    return *this;
}

ib::sim::fr::idl::ControllerStatus& ib::sim::fr::idl::ControllerStatus::operator=(ControllerStatus &&x)
{
    m_senderAddr = std::move(x.m_senderAddr);
    m_timeNs = x.m_timeNs;
    m_pocState = x.m_pocState;

    return *this;
}

size_t ib::sim::fr::idl::ControllerStatus::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t ib::sim::fr::idl::ControllerStatus::getCdrSerializedSize(const ib::sim::fr::idl::ControllerStatus& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += ib::mw::idl::EndpointAddress::getCdrSerializedSize(data.senderAddr(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void ib::sim::fr::idl::ControllerStatus::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_senderAddr;
    scdr << m_timeNs;
    scdr << (uint32_t)m_pocState;
}

void ib::sim::fr::idl::ControllerStatus::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_senderAddr;
    dcdr >> m_timeNs;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_pocState = (ib::sim::fr::idl::PocState)enum_value;
    }
}

size_t ib::sim::fr::idl::ControllerStatus::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ib::mw::idl::EndpointAddress::getMaxCdrSerializedSize(current_align); 



    return current_align;
}

bool ib::sim::fr::idl::ControllerStatus::isKeyDefined()
{
    return true;
}

void ib::sim::fr::idl::ControllerStatus::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_senderAddr;  
	 
	 
}



