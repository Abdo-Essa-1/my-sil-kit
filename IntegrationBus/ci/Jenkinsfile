// vim: set ft=groovy:
// a simple cmake and ctest  CI file

//##########################################
// modify these top level variables to change the build targets and cmake options
//##########################################
// pipeline config
projectName="vib-main"
artifactName='IntegrationBus'
keepNumBuilds=10 //number of log files on Jenkins, workspaces are always cleaned
publishToArtifactory=true
//debug binaries are only build when doing a release to customers
buildDebugBin=true
cleanBuild=true

//linux docker image
dockerImage ="vib/ubuntu"
dockerImageDir ="./IntegrationBus/ci" //for packaging additional files in docker, e.g. "."
dockerImageFile ="${dockerImageDir}/Dockerfile.vib-ubuntu"
// artifactory for archiving / packaging
artifactoryServer = Artifactory.server('IntegrationBusArtifactory')
artifactoryRepo = '***VIB-820 Removed***'
artifactoryBuildInfo = Artifactory.newBuildInfo()

//  global cmake args for all builds
cmakeArgsRelease="-DIB_INSTALL_SOURCE=ON " //only distribute source and docs in release mode
cmakeArgs =" -DCMAKE_EXPORT_NO_PACKAGE_REGISTRY=ON "
gitBranch="master" // overriden in parallel pipeline based on scm vars
//##########################################
// Utilities
//##########################################
@NonCPS
def isDockerNode(label) {
    return label.toUpperCase().contains('DOCKER')
}

@NonCPS
def isClangBuild(label) {
    return label.toUpperCase().contains('CLANG')
}

def setBuildRetention(bi) {
    if(gitBranch == 'master' || gitBranch == 'origin/master') {
        bi.retention(maxBuilds: 20, deleteBuildArtifacts: true, async: true)
    } else {
        bi.retention(maxBuilds: 2, maxDays: 50, deleteBuildArtifacts: true, async: true)
    }
}

//recursive submodule git checkout 
def checkoutGit() {
    return checkout([$class: 'GitSCM',
            branches: scm.branches,
            doGenerateSubmoduleConfigurations: false,
            extensions: [
                [$class: 'SubmoduleOption',
                    disableSubmodules: false,
                    parentCredentials: false,
                    recursiveSubmodules: true,
                    reference: '',
                    trackingSubmodules: false]],
            submoduleCfg: [],
            userRemoteConfigs: scm.userRemoteConfigs
        ])
}
def shallowCheckoutGit() {
    return checkout([$class: 'GitSCM',
            branches: scm.branches,
            doGenerateSubmoduleConfigurations: false,
            userRemoteConfigs: scm.userRemoteConfigs
        ])
}

def archiveToArtifactory(scm, pattern) {
    //find the file to upload
    def files = findFiles(glob: pattern)
    if(files.size() != 1) {
        error("ERROR: single file ${pattern} required: findFiles returned: ${files}")
    } else {
        print("INFO: found build artifact ${files[0]}")
        if (! publishToArtifactory ) {
            print("INFO: skipping publishing to artifactory because of user request")
            return
        }

        def fileName = files[0].name
        def spec = """{
            "files": [{
                "pattern": "${files[0]}",
                "target" : "${artifactoryRepo}/${projectName}/${scm.GIT_BRANCH}/${scm.GIT_COMMIT}/${fileName}",
                "props"  : "git_commit=${scm.GIT_COMMIT};git_branch=${scm.GIT_BRANCH};git_url=${scm.GIT_URL}"
        }]}"""
        print("artifactory spec=${spec}")
        def buildInfo = artifactoryServer.upload(
            spec: spec,
            failNoOp: true
        )
        setBuildRetention(buildInfo)
        artifactoryBuildInfo.append(buildInfo)
    }
}

// runOnNode: a helper that runs the userStages closure on an appropriate node
// i.e., this allows running the same stages on docker and windows
def runOnNode(buildFlags, userStages) {
    def buildName = buildFlags["name"]
    def dockerExtraArgs = ""
    if( "ubuntu_version" in buildFlags) {
        dockerExtraArgs = " --build-arg UBUNTU_VERSION=${buildFlags.ubuntu_version}"
    }

    def wsDir = "workspace/${env.JOB_NAME}/" \
                 + buildName.replaceAll(" ", "_") + "_${env.BUILD_NUMBER}"
    return {
        node(buildFlags["agent"]) {
            ws(wsDir) {
                try {
                    if(isDockerNode(buildFlags["agent"])) {
                        //the built image should be cached and shared anyway
                        shallowCheckoutGit()
                        docker.build(dockerImage,  //XXX this might require a checkout for ./ci to be present
                                "--build-arg ARTIFACTORY=${artifactoryServer.url} ${dockerExtraArgs} -f ${dockerImageFile} ${dockerImageDir}")
                        print("Calling docker inside in ${pwd()}")
                        docker.image(dockerImage).inside {
                            userStages()
                        }
                    } else {
                        print("Working in ${pwd()}")
                        userStages()
                    }
                } finally {
                    cleanWs(cleanWhenNotBuilt: true, cleanWhenFailure: true,
                            cleanWhenSuccess: true, cleanWhenAborted: true,
                            deleteDirs: true, disableDeferredWipeout: true)
                }
            } //ws
        } //node
    } //return
}

// Canonical way on CMake + Ninja + VS is to source the appropriate vcvarsall script
// before invoking cmake -G Ninja
def getVsBuildEnv(arch, version){
    def localEnv=[]
    def toolDir="${tool 'BuildTools2019'}\\..\\..\\.."
    // get vcvarsall.bat environment
    def envstr = bat returnStdout: true, script: "\"${toolDir}\\VC\\Auxiliary\\Build\\vcvarsall.bat\" ${arch} -vcvars_ver=${version} &set"
    def lines = envstr.split("\r\n")
    for(int i = 0; i < lines.size(); i++) {
        def line = lines[i]
        if(line =~ /^\S+=.*/) {
            localEnv += line
        }
    }
    return localEnv
}

//helper to invoke  cmake platform independently with uniform arguments
def runCmake(buildType, extraArgs=""){
    cmakeBuild(
        installation: 'InSearchPath',
        cleanBuild: cleanBuild,
        buildType: "${buildType}",
        buildDir: "_build_${buildType}",
        generator: "Ninja",
        cmakeArgs: "${cmakeArgs} -DCMAKE_BUILD_TYPE=${buildType} ${extraArgs}",
        steps: [[args: "--target package --config ${buildType}  --parallel", withCmake: true]]
    )
}

def run(what) {
    if(isUnix()) {
        sh "${what}"
    } else {
        bat "${what}"
    }
}
// quote percent sign for DOS batch, eg. uses in git log --format=%ct
def quoteBat(userStr) {
    def res="@" //disable printing the command itself
    for(int i = 0; i < userStr.size(); i++) {
        def ch = userStr[i]
        if( ch == '%' ) {
            res += "%%"
        } else{
            res += ch
        }
    }
    return res
}
def runWithOutput(what) {
    if(isUnix()) {
        return sh(script: "${what}", returnStdout: true).trim()
    } else {
        return bat(script: "${quoteBat(what)}", returnStdout: true).trim()
    }
}

//##########################################
//the actual build process
//##########################################

// instantiate a build on an appropriate node
def doBuild(Map buildFlags) {
    return runOnNode(buildFlags, {
        def buildName = buildFlags["name"]

        def extraArgs = ""
        def buildEnv = []
        def scmVars = [:]

        stage("Git checkout and ENV setup (${buildName})") {
            if("cc" in buildFlags) {
                cc = buildFlags["cc"]
                buildEnv.add("CC=${cc}")
                extraArgs += " -DCMAKE_C_COMPILER=${cc}"
            }
            if("cxx" in buildFlags) {
                cxx = buildFlags["cxx"]
                buildEnv.add("CXX=${cxx}")
                extraArgs += " -DCMAKE_CXX_COMPILER=${cxx}"
                
            }
            if("msvc_version" in buildFlags) {
                // visual studio toolset selection via vcvarsall env
                buildEnv = buildEnv + getVsBuildEnv(buildFlags["arch"], buildFlags["msvc_version"])
                buildEnv.add("MSBUILDDISABLENODEREUSE=1") //fixes spurious windows failures

                msvc_toolset = buildFlags["msvc_version"].replace(".","") // 14.1 -> 141
                extraArgs += " -DMSVC_TOOLSET_VERSION=${msvc_toolset}" //needed for binary download URL resolution
                extraArgs += " -DCMAKE_CXX_COMPILER=cl -DCMAKE_C_COMPILER=cl"
            }

            print("DEBUG extraArgs=${extraArgs}")
            scmVars = checkoutGit()

            // For reproducible build set SOURCE_DATE_EPOCH to time of last commit
            def commitTime = runWithOutput("git log --max-count=1 --format=%ct -r origin/master")
            print("DEBUG scmVars=${scmVars}, commitTime=${commitTime}, TZ=${env.TZ}, LC_ALL=${env.LC_ALL}")
            buildEnv.add("SOURCE_DATE_EPOCH=${commitTime}")
            buildEnv.add("TZ=UTC")
            buildEnv.add("LC_ALL=C")
            buildEnv.add("LANG=C")
            // save branch name for publishing stage
            gitBranch = scmVars.GIT_BRANCH
        }

        stage("Cmake Release Build (${buildName})") {
            print("${buildName} --  running cmake Release")
            withEnv(buildEnv) {
                print("Debug: TZ=${env.TZ} LC_ALL=${env.LC_ALL}")
                runCmake("Release", "${cmakeArgsRelease}" + "${extraArgs}" )
            }
        }
        stage("Unit Tests Release (${buildName})") {
            dir("_build_Release") {

                timeout(time: 10, unit: 'MINUTES') {
                    ctest(
                        installation: 'InSearchPath',
                        arguments: "--verbose --build-config Release -R '^Test.*'"
                    )
                }
                junit("**/*gtestresults.xml")

            }
        }

        stage("Integration Tests Release (${buildName})") {
            dir("_build_Release") {
                timeout(time: 10, unit: 'MINUTES') {
                    ctest(
                        installation: 'InSearchPath',
                        arguments: "--verbose --build-config Release -R '^ITest.*'"
                    )
                }
                junit("**/*gtestresults.xml")

            }
        }

        if(buildDebugBin) {
            stage("Cmake Debug Build (${buildName})") {
                print("${buildName} --  running cmake Debug")
                withEnv(buildEnv) {
                    runCmake("Debug", extraArgs)
                }
            }

            stage(" Bundle and Archive Packages (${buildName})") {
                run "python ${dockerImageDir}/package.py \"_build_Release/${artifactName}-*-Release.zip\" \"_build_Debug/${artifactName}-*-Debug.zip\""
                archiveToArtifactory(scmVars, "${artifactName}-*.zip")

                // safe the PDB files on windows
                if(!isUnix()) {
                    // package PDB files without rebuilding
                    def pdbArchive = "_build_Debug/IntegrationBus-${buildName}-PDB.zip"
                    run "python -mzipfile -c ${pdbArchive} _build_Debug/package-pdb/ _build_Release/package-pdb/"
                    archiveToArtifactory(scmVars, pdbArchive)
                }
            }
        }
    })
}

// node main entry. parallel invocation of all builds, packaging
node {
    // pipeline settings
    properties([
        buildDiscarder(logRotator(numToKeepStr: "${keepNumBuilds}")),
    ])   

    def builds = [:]

    // "Name of the target" : "Name of the target", "required node label", "generator name")
    builds.put("VS2017-Win64", doBuild(name: "VS2017-Win64", agent: "ninja && buildtools2019", arch:"x64", msvc_version:"14.1") )
    builds.put("VS2015-Win64", doBuild(name: "VS2015-Win64", agent: "ninja && buildtools2019", arch:"x64", msvc_version:"14.0") )
    builds.put("VS2017-Win32", doBuild(name: "VS2017-Win32", agent: "ninja && buildtools2019", arch:"x64_x86", msvc_version:"14.1") )
    builds.put("VS2015-Win32", doBuild(name: "VS2015-Win32", agent: "ninja && buildtools2019", arch:"x64_x86", msvc_version:"14.0") )
    builds.put("Ubuntu-18.04-clang", doBuild(name: "Ubuntu-18.04-clang", agent: "docker && linux", cc:"clang", cxx:"clang++") )
    builds.put("Ubuntu-18.04-gcc"  , doBuild(name: "Ubuntu-18.04-gcc",   agent: "docker && linux", cc: "gcc",  cxx:"g++") )
    builds.put("Ubuntu-20.04-gcc"  , doBuild(name: "Ubuntu-20.04-gcc",   agent: "docker && linux", cc: "gcc",  cxx:"g++", ubuntu_version: "20.04") )
    
    try {
        parallel(builds)
    }
    finally {
        if(publishToArtifactory) {
            stage("Publishing Build Info") {
                print("INFO: publishing artifactory build info for branch ${gitBranch}")
                setBuildRetention(artifactoryBuildInfo)
                artifactoryServer.publishBuildInfo(artifactoryBuildInfo)
            }
        }
        cleanWs(cleanWhenNotBuilt: true, cleanWhenFailure: true,
                cleanWhenSuccess: true, cleanWhenAborted: true,
                deleteDirs: true, disableDeferredWipeout: true )
    }
}
